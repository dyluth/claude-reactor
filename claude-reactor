#!/usr/bin/env bash
#
# claude-reactor: A wrapper script to manage and connect to the interactive Claude Docker environment.
#
# This script intelligently handles the container lifecycle:
# - Builds the image if it doesn't exist (must be run from the project root for the first build).
# - Starts the container if it's stopped.
# - Attaches to the container if it's already running.
# - Creates the container on its first run.
# - Handles authentication by preferring an API key but allowing an interactive override.

set -e

# --- Script Variables ---
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
VERBOSE=false

# --- Configuration ---
BASE_IMAGE_NAME="claude-reactor"
BASE_CONTAINER_NAME="claude-agent"
CONFIG_FILE=".claude-reactor"
CLAUDE_CONFIG_SNAPSHOT=""

# Cleanup function
cleanup() {
    if [ -n "$CLAUDE_CONFIG_SNAPSHOT" ] && [ -f "$CLAUDE_CONFIG_SNAPSHOT" ]; then
        rm -f "$CLAUDE_CONFIG_SNAPSHOT" 2>/dev/null || true
    fi
}

# Set cleanup trap
trap cleanup EXIT

# --- Helper Functions ---
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

A wrapper script to manage and connect to the interactive Claude Docker environment.

OPTIONS:
    --variant VARIANT     Set container variant (base, go, full, cloud, k8s)
    --list-variants       Show available variants
    --show-config         Show current configuration
    --interactive-login   Force interactive UI login instead of API key
    --rebuild             Force rebuild of Docker image
    --clean               Remove existing container and start fresh
    --danger              Launch Claude CLI with --dangerously-skip-permissions
    --shell               Launch bash shell instead of Claude CLI directly
    --install             Install claude-reactor to /usr/local/bin (requires sudo)
    --uninstall           Remove claude-reactor from /usr/local/bin (requires sudo)
    --verbose, -v         Enable verbose output
    --help, -h            Show this help message

EXAMPLES:
    $SCRIPT_NAME                         # Launch Claude CLI directly (uses saved config)
    $SCRIPT_NAME --variant go            # Use Go variant and save preference
    $SCRIPT_NAME --shell                 # Launch bash shell instead of Claude CLI
    $SCRIPT_NAME --danger                # Launch Claude CLI with --dangerously-skip-permissions
    $SCRIPT_NAME --variant full --danger # Use full variant with danger mode
    $SCRIPT_NAME --list-variants         # Show available variants
    $SCRIPT_NAME --show-config           # Show current configuration
    $SCRIPT_NAME --rebuild               # Force rebuild current variant
    $SCRIPT_NAME --clean                 # Remove container and start fresh
    $SCRIPT_NAME --install               # Install to PATH

EOF
}

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo "[VERBOSE] $1"
    fi
}

log_info() {
    echo "$1"
}

log_error() {
    echo "Error: $1" >&2
}

# --- Configuration Functions ---
save_config() {
    local variant="$1"
    local danger_mode="$2"
    
    {
        echo "variant=$variant"
        if [ "$danger_mode" = true ]; then
            echo "danger=true"
        fi
    } > "$CONFIG_FILE"
    
    log_verbose "Saved configuration: variant=$variant, danger=$danger_mode"
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        log_verbose "Loading configuration from $CONFIG_FILE"
        
        # Load variant
        SAVED_VARIANT=$(grep "^variant=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
        
        # Load danger setting
        SAVED_DANGER=$(grep "^danger=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
        if [ "$SAVED_DANGER" = "true" ]; then
            SAVED_DANGER=true
        else
            SAVED_DANGER=false
        fi
        
        log_verbose "Loaded: variant=$SAVED_VARIANT, danger=$SAVED_DANGER"
    else
        log_verbose "No configuration file found"
        SAVED_VARIANT=""
        SAVED_DANGER=false
    fi
}

auto_detect_variant() {
    log_verbose "Auto-detecting project variant..."
    
    if [ -f "go.mod" ] || [ -f "go.sum" ]; then
        echo "go"
    elif [ -f "Cargo.toml" ] || [ -f "Cargo.lock" ]; then
        echo "full"  # Rust needs full environment
    elif [ -f "pom.xml" ] || [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
        echo "full"  # Java needs full environment
    elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] || [ -f "Pipfile" ]; then
        echo "base"  # Python already in base
    elif [ -f "package.json" ]; then
        echo "base"  # Node.js already in base
    else
        echo "base"  # Default fallback
    fi
}

determine_variant() {
    if [ -n "$EXPLICIT_VARIANT" ]; then
        echo "$EXPLICIT_VARIANT"
    elif [ -n "$SAVED_VARIANT" ]; then
        log_verbose "Using saved variant: $SAVED_VARIANT"
        echo "$SAVED_VARIANT"
    else
        local detected=$(auto_detect_variant)
        log_verbose "Auto-detected variant: $detected"
        echo "$detected"
    fi
}

validate_variant() {
    local variant="$1"
    case "$variant" in
        base|go|full|cloud|k8s)
            return 0
            ;;
        *)
            log_error "Invalid variant: $variant"
            log_error "Available variants: base, go, full, cloud, k8s"
            return 1
            ;;
    esac
}

show_variants() {
    cat << EOF
Available container variants:

  base   - Node.js, Python, basic development tools (smallest)
  go     - Base + Go toolchain and utilities
  full   - Go + Rust, Java, database clients
  cloud  - Full + AWS/GCP/Azure CLIs
  k8s    - Full + Enhanced Kubernetes tools (helm, k9s)

Current configuration:
EOF
    if [ -f "$CONFIG_FILE" ]; then
        cat "$CONFIG_FILE" | sed 's/^/  /'
    else
        echo "  No saved configuration (will auto-detect)"
    fi
}

show_current_config() {
    load_config
    local variant=$(determine_variant)
    
    echo "Current configuration:"
    echo "  Variant: $variant"
    echo "  Danger mode: ${SAVED_DANGER:-false}"
    echo "  Config file: $CONFIG_FILE"
    
    if [ -f "$CONFIG_FILE" ]; then
        echo "  Status: Configuration saved"
        echo ""
        echo "Raw config file:"
        cat "$CONFIG_FILE" | sed 's/^/    /'
    else
        echo "  Status: No saved configuration (auto-detecting)"
        echo "  Auto-detected: $(auto_detect_variant)"
    fi
}

# --- Argument Parsing ---
REBUILD=false
CLEAN=false
INTERACTIVE_LOGIN=false
DANGER_MODE=false
SHELL_MODE=false
INSTALL=false
UNINSTALL=false
EXPLICIT_VARIANT=""
SHOW_VARIANTS=false
SHOW_CONFIG=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_usage
            exit 0
            ;;
        --variant)
            if [[ -z "$2" ]]; then
                log_error "--variant requires a value"
                exit 1
            fi
            EXPLICIT_VARIANT="$2"
            shift 2
            ;;
        --list-variants)
            SHOW_VARIANTS=true
            shift
            ;;
        --show-config)
            SHOW_CONFIG=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --rebuild)
            REBUILD=true
            shift
            ;;
        --clean)
            CLEAN=true
            shift
            ;;
        --interactive-login)
            INTERACTIVE_LOGIN=true
            shift
            ;;
        --danger)
            DANGER_MODE=true
            shift
            ;;
        --shell)
            SHELL_MODE=true
            shift
            ;;
        --install)
            INSTALL=true
            shift
            ;;
        --uninstall)
            UNINSTALL=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# --- Validate Explicit Variant First ---
if [ -n "$EXPLICIT_VARIANT" ]; then
    if ! validate_variant "$EXPLICIT_VARIANT"; then
        exit 1
    fi
fi

# --- Load Configuration ---
load_config

# --- Early Configuration Determination for Special Commands ---
# We need to determine VARIANT early for commands that might need it
VARIANT=${EXPLICIT_VARIANT:-${SAVED_VARIANT:-$(auto_detect_variant)}}

# --- Save Configuration if Explicit Options Were Provided ---
# This must happen before early exits so that --show-config shows saved config
if [ -n "$EXPLICIT_VARIANT" ] || [ "$DANGER_MODE" = true ]; then
    save_config "$VARIANT" "$DANGER_MODE"
fi

# --- Handle Special Commands ---
if [ "$SHOW_VARIANTS" = true ]; then
    show_variants
    exit 0
fi

if [ "$SHOW_CONFIG" = true ]; then
    show_current_config
    exit 0
fi

# --- Install/Uninstall Handling ---
if [ "$INSTALL" = true ]; then
    log_info "Installing claude-reactor to /usr/local/bin..."
    
    # Get the absolute path of this script
    SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"
    
    # Check if we have sudo access
    if ! sudo -n true 2>/dev/null; then
        log_info "Requesting sudo access to install to /usr/local/bin..."
    fi
    
    # Copy script to /usr/local/bin
    if sudo cp "$SCRIPT_PATH" /usr/local/bin/claude-reactor; then
        sudo chmod +x /usr/local/bin/claude-reactor
        log_info "✅ claude-reactor installed successfully!"
        log_info "You can now run 'claude-reactor' from anywhere."
        exit 0
    else
        log_error "Failed to install claude-reactor."
        exit 1
    fi
fi

if [ "$UNINSTALL" = true ]; then
    log_info "Removing claude-reactor from /usr/local/bin..."
    
    # Check if the file exists
    if [ ! -f "/usr/local/bin/claude-reactor" ]; then
        log_error "claude-reactor is not installed in /usr/local/bin"
        exit 1
    fi
    
    # Check if we have sudo access
    if ! sudo -n true 2>/dev/null; then
        log_info "Requesting sudo access to remove from /usr/local/bin..."
    fi
    
    # Remove the script
    if sudo rm /usr/local/bin/claude-reactor; then
        log_info "✅ claude-reactor uninstalled successfully!"
        exit 0
    else
        log_error "Failed to uninstall claude-reactor."
        exit 1
    fi
fi

# --- Dependency Check ---
if ! command -v docker &> /dev/null; then
    log_error "Docker is not installed or not in your PATH. Please install Docker Desktop."
    exit 1
fi

log_verbose "Docker found: $(docker --version)"

# --- Determine Names from Early Variant Assignment ---
IMAGE_NAME="$BASE_IMAGE_NAME-$VARIANT"
CONTAINER_NAME="$BASE_CONTAINER_NAME-$VARIANT"

log_verbose "Using variant: $VARIANT"
log_verbose "Image name: $IMAGE_NAME"
log_verbose "Container name: $CONTAINER_NAME"

# --- Apply Saved Danger Mode ---
if [ "$SAVED_DANGER" = true ] && [ "$DANGER_MODE" = false ]; then
    log_verbose "Applying saved danger mode setting"
    DANGER_MODE=true
fi

# --- Container Cleanup ---
# --rebuild implicitly runs --clean
if [ "$REBUILD" = true ]; then
    CLEAN=true
    log_verbose "Rebuild requested, enabling container cleanup"
fi

if [ "$CLEAN" = true ]; then
    log_info "Cleaning up existing container..."
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        log_verbose "Stopping container $CONTAINER_NAME"
        docker stop "$CONTAINER_NAME" &> /dev/null || true
        log_verbose "Removing container $CONTAINER_NAME"
        docker rm "$CONTAINER_NAME" &> /dev/null || true
        log_info "Container $CONTAINER_NAME removed."
    else
        log_verbose "No existing container to clean up."
    fi
fi

# --- Image Build Check ---
# If the image doesn't exist or rebuild is requested, build it
if [ "$REBUILD" = true ] || ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
    if [ "$REBUILD" = true ]; then
        log_info "Rebuilding Docker image '$IMAGE_NAME'..."
        log_verbose "Removing existing image"
        docker rmi "$IMAGE_NAME" &> /dev/null || true
    else
        log_info "Docker image '$IMAGE_NAME' not found."
    fi
    
    if [ -f "Dockerfile" ]; then
        log_info "Dockerfile found in current directory. Building the image..."
        log_info "Building variant: $VARIANT"
        if [ "$VERBOSE" = true ]; then
            docker build --target "$VARIANT" -t "$IMAGE_NAME" .
        else
            docker build --target "$VARIANT" -t "$IMAGE_NAME" . > /dev/null
        fi
        if [ $? -ne 0 ]; then
            log_error "Docker build failed for variant '$VARIANT'."
            log_error "Make sure the Dockerfile has a '$VARIANT' build stage."
            exit 1
        fi
        log_info "Image '$IMAGE_NAME' (variant: $VARIANT) built successfully."
    else
        log_error "Dockerfile not found. Please run '$SCRIPT_NAME' from the project root once to build the image."
        exit 1
    fi
else
    log_verbose "Docker image '$IMAGE_NAME' already exists."
fi

# --- Container Lifecycle Management ---
# Check if the container exists, regardless of its state (running or stopped)
if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    # Container exists. Check if it's running.
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        log_info "Attaching to running container '${CONTAINER_NAME}'..."
        log_verbose "Container is already running"
    else
        # Container is stopped, so start it.
        log_info "Starting stopped container '${CONTAINER_NAME}'..."
        log_verbose "Starting container $CONTAINER_NAME"
        docker start "$CONTAINER_NAME" > /dev/null
        if [ $? -ne 0 ]; then
            log_error "Failed to start container."
            exit 1
        fi
        log_verbose "Container started successfully"
    fi
else
    # Container does not exist. Create and run it for the first time.
    log_info "Creating and starting new container '${CONTAINER_NAME}'..."
    
    # Ensure host directories exist for mounting
    mkdir -p "${HOME}/.claude"
    mkdir -p "${HOME}/.kube"
    
    # Base arguments for the docker run command
    DOCKER_RUN_ARGS=(
        -d
        --name "$CONTAINER_NAME"
        -v "$(pwd):/app"
        -v "${HOME}/.kube:/home/claude/.kube"
        -v "${HOME}/.claude:/home/claude/.claude"
        -v "${HOME}/.gitconfig:/home/claude/.gitconfig"
        -v "/var/run/docker.sock:/var/run/docker.sock"
    )
    
    # Mount host Claude config file if it exists and is valid JSON
    if [ -f "${HOME}/.claude.json" ]; then
        # Create a temporary snapshot to avoid race conditions during container startup
        CLAUDE_CONFIG_SNAPSHOT="/tmp/.claude.json.$$"
        if cp "${HOME}/.claude.json" "$CLAUDE_CONFIG_SNAPSHOT" 2>/dev/null; then
            # Validate the snapshot before mounting
            if command -v jq >/dev/null 2>&1 && jq empty "$CLAUDE_CONFIG_SNAPSHOT" >/dev/null 2>&1; then
                DOCKER_RUN_ARGS+=("-v" "$CLAUDE_CONFIG_SNAPSHOT:/home/claude/.claude.json")
                log_verbose "Mounting Claude config snapshot for authentication persistence"
            else
                log_warning "Claude config snapshot has invalid JSON, skipping mount"
                log_warning "Claude CLI will create fresh configuration in container"
                rm -f "$CLAUDE_CONFIG_SNAPSHOT" 2>/dev/null || true
            fi
        else
            log_warning "Could not create Claude config snapshot, skipping mount"
        fi
    fi
    
    # Handle authentication method
    if [ "$INTERACTIVE_LOGIN" = true ]; then
        log_info "Using interactive UI login (--interactive-login specified)."
        log_verbose "Skipping API key authentication"
    elif [ -f "${HOME}/.env" ]; then
        log_info "API key file found at ~/.env. Using API key authentication."
        DOCKER_RUN_ARGS+=("--env-file" "${HOME}/.env")
        log_verbose "Added --env-file ${HOME}/.env to docker run args"
    else
        log_info "No API key file found at ~/.env. Using interactive UI login."
        log_verbose "Create ~/.env with ANTHROPIC_API_KEY to use API key authentication"
    fi
    
    log_verbose "Docker run command: docker run ${DOCKER_RUN_ARGS[*]} $IMAGE_NAME"
    
    # Execute the run command
    docker run "${DOCKER_RUN_ARGS[@]}" "$IMAGE_NAME" > /dev/null
    
    if [ $? -ne 0 ]; then
        log_error "Failed to run container."
        exit 1
    fi
    log_verbose "Container created and started successfully"
fi

# --- Container Health Check ---
log_verbose "Checking container health..."
for i in {1..5}; do
    if docker exec "$CONTAINER_NAME" echo "Container is responsive" &> /dev/null; then
        log_verbose "Container health check passed"
        break
    fi
    if [ $i -eq 5 ]; then
        log_error "Container is not responding after 5 attempts."
        exit 1
    fi
    log_verbose "Container health check attempt $i failed, retrying..."
    sleep 1
done

# --- Ensure Claude Configuration Persistence ---
log_verbose "Setting up Claude CLI configuration persistence..."

# Ensure the container's .claude directory has proper ownership
docker exec --user root "$CONTAINER_NAME" chown -R claude:claude /home/claude/.claude 2>/dev/null || true

# Ensure mounted .claude.json file has proper ownership if it exists
if [ -f "${HOME}/.claude.json" ]; then
    docker exec --user root "$CONTAINER_NAME" chown claude:claude /home/claude/.claude.json 2>/dev/null || true
fi

# Ensure project directory structure exists
log_verbose "Setting up Claude CLI project directory structure"
docker exec --user claude "$CONTAINER_NAME" sh -c 'mkdir -p /home/claude/.claude/projects/-app 2>/dev/null || true'

# If Claude config file isn't mounted from host, create basic trust configuration
if [ ! -f "${HOME}/.claude.json" ]; then
    log_verbose "Creating initial Claude CLI configuration for /app directory trust"
    docker exec --user claude "$CONTAINER_NAME" sh -c 'cat > /home/claude/.claude.json << "EOF"
{
  "hasTrustDialogAccepted": true,
  "hasCompletedProjectOnboarding": true,
  "trustedDirectories": {"/app": true}
}
EOF' 2>/dev/null || true
else
    log_verbose "Using mounted Claude config file from host"
fi

# Ensure claude user can access Docker socket
log_verbose "Configuring Docker socket access for claude user"
docker exec --user root "$CONTAINER_NAME" sh -c '
    # Get the group ID of the docker socket
    DOCKER_GID=$(stat -c %g /var/run/docker.sock 2>/dev/null || echo "999")
    # Add claude user to docker group (create if needed)
    getent group docker >/dev/null || groupadd -g $DOCKER_GID docker
    usermod -aG docker claude
' 2>/dev/null || true

# --- Attach to the Container ---
# By this point, the container is guaranteed to be running.
if [ "$SHELL_MODE" = true ]; then
    # User explicitly requested shell access
    log_info "Launching bash shell in container"
    log_verbose "Connecting to container with git-aware prompt enabled"
    docker exec -it --user claude "$CONTAINER_NAME" bash-with-prompt
elif [ "$DANGER_MODE" = true ]; then
    # User requested danger mode - launch Claude CLI with bypassed permissions
    log_info "⚠️  DANGER MODE: Launching Claude CLI with --dangerously-skip-permissions"
    log_verbose "Connecting directly to Claude CLI with bypassed permissions"
    docker exec -it --user claude "$CONTAINER_NAME" claude --dangerously-skip-permissions
else
    # Default behavior - launch Claude CLI directly
    log_info "Launching Claude CLI in container"
    log_verbose "Connecting directly to Claude CLI"
    docker exec -it --user claude "$CONTAINER_NAME" claude
fi