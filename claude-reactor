#!/usr/bin/env bash
#
# claude-reactor: A wrapper script to manage and connect to the interactive Claude Docker environment.
#
# This script intelligently handles the container lifecycle:
# - Builds the image if it doesn't exist (must be run from the project root for the first build).
# - Starts the container if it's stopped.
# - Attaches to the container if it's already running.
# - Creates the container on its first run.
# - Handles authentication by preferring an API key but allowing an interactive override.
set -e

# --- Script Variables ---
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
VERBOSE=false

# --- Configuration ---
BASE_IMAGE_NAME="claude-reactor"
BASE_CONTAINER_NAME="claude-reactor"
CONFIG_FILE=".claude-reactor"

# --- Architecture Detection Functions ---
detect_architecture() {
    local arch_raw=$(uname -m)
    case "$arch_raw" in
        x86_64|amd64)
            echo "amd64"
            ;;
        arm64|aarch64)
            echo "arm64"
            ;;
        *)
            log_error "Unsupported architecture: $arch_raw"
            log_error "Supported architectures: x86_64, amd64, arm64, aarch64"
            return 1
            ;;
    esac
}

get_docker_platform() {
    local arch=$(detect_architecture)
    case "$arch" in
        amd64)
            echo "linux/amd64"
            ;;
        arm64)
            echo "linux/arm64"
            ;;
        *)
            log_error "Cannot determine Docker platform for architecture: $arch"
            return 1
            ;;
    esac
}

# --- Helper Functions ---
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

A wrapper script to manage and connect to the interactive Claude Docker environment.
OPTIONS:
    --variant VARIANT     Set container variant (base, go, full, cloud, k8s)
    --account ACCOUNT     Set Claude account for this folder (creates isolated authentication)
    --apikey APIKEY       Set API key for current account (saves to project-specific file)
    --mount PATH          Mount additional directory to /mnt/basename (can be used multiple times)
    --list-accounts       Show available Claude accounts
    --list-variants       Show available variants
    --show-config         Show current configuration
    --interactive-login   Force interactive UI login instead of API key
    --rebuild             Force rebuild of Docker image
    --clean               Remove current project/account container and start fresh
    --clean-all           Remove ALL claude-reactor containers
    --danger              Launch Claude CLI with --dangerously-skip-permissions
    --shell               Launch bash shell instead of Claude CLI directly
    --install             Install claude-reactor to /usr/local/bin (requires sudo)
    --uninstall           Remove claude-reactor from /usr/local/bin (requires sudo)
    --verbose, -v         Enable verbose output
    --help, -h            Show this help message
EOF
}

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo "[VERBOSE] $1"
    fi
}

log_info() {
    echo "$1"
}

log_error() {
    echo "Error: $1" >&2
}

log_warning() {
    echo "Warning: $1" >&2
}

# --- API Key Management Functions ---
save_api_key() {
    local account_id="$1"
    local api_key="$2"
    
    if [ -z "$account_id" ]; then
        local env_file=".claude-reactor-env"
    else
        local env_file=".claude-reactor-${account_id}-env"
    fi
    
    echo "ANTHROPIC_API_KEY=$api_key" > "$env_file"
    chmod 600 "$env_file"
    
    log_info "API key saved to $env_file"
    log_verbose "Saved API key for account: ${account_id:-default}"
}

get_api_key_file() {
    local account_id="$1"
    
    if [ -z "$account_id" ]; then
        local env_file=".claude-reactor-env"
    else
        local env_file=".claude-reactor-${account_id}-env"
    fi
    
    echo "$env_file"
}

get_claude_account_dir() {
    local account_id="$1"
    if [ -n "$account_id" ] && [ "$account_id" != "default" ]; then
        echo "${HOME}/.claude-reactor/${account_id}"
    else
        # For default account, use main Claude directories (no isolation)
        echo ""
    fi
}

update_claude_settings_for_mounts() {
    # Only update settings if we have mount paths
    if [ ${#MOUNT_PATHS[@]} -eq 0 ]; then
        log_verbose "No mount paths to configure"
        return
    fi
    
    local settings_file=".claude/settings.local.json"
    local claude_dir=".claude"
    
    # Create .claude directory if it doesn't exist
    mkdir -p "$claude_dir"
    
    # Build array of mount paths as they appear in container
    local mount_dirs=()
    for mount_path in "${MOUNT_PATHS[@]}"; do
        local basename=$(basename "$mount_path")
        mount_dirs+=("/mnt/$basename")
    done
    
    # Read existing settings or create empty object
    local existing_settings="{}"
    if [ -f "$settings_file" ]; then
        if command -v jq >/dev/null 2>&1 && jq empty "$settings_file" >/dev/null 2>&1; then
            existing_settings=$(cat "$settings_file")
            log_verbose "Read existing Claude settings from $settings_file"
        else
            log_verbose "Existing settings file has invalid JSON, creating new one"
        fi
    fi
    
    # Build new additionalDirectories array (preserve existing + add mounts)
    local existing_dirs=""
    if command -v jq >/dev/null 2>&1; then
        # Get existing additionalDirectories, default to empty array if not present
        existing_dirs=$(echo "$existing_settings" | jq -r '.additionalDirectories // [] | @json' 2>/dev/null || echo "[]")
        
        # Create JSON array of mount directories
        local mount_dirs_json=$(printf '%s\n' "${mount_dirs[@]}" | jq -R . | jq -s .)
        
        # Merge existing and new directories, removing duplicates
        local combined_dirs=$(echo "$existing_dirs $mount_dirs_json" | jq -s 'add | unique')
        
        # Update settings with merged directories, preserving all other settings
        local updated_settings=$(echo "$existing_settings" | jq --argjson dirs "$combined_dirs" '.additionalDirectories = $dirs')
        
        # Write updated settings
        echo "$updated_settings" | jq . > "$settings_file"
        
        local mount_count=${#mount_dirs[@]}
        log_info "ðŸ“ Updated Claude settings with $mount_count mounted director$([ $mount_count -eq 1 ] && echo "y" || echo "ies")"
        log_verbose "Mount directories: ${mount_dirs[*]}"
        log_verbose "Settings file: $settings_file"
    else
        log_warning "jq not found, cannot update Claude settings file"
        log_verbose "Install jq to automatically configure mounted directories for Claude"
    fi
}

# --- Configuration Functions ---
save_config() {
    local variant="$1"
    local danger_mode="$2"
    local account_id="$3"
    
    {
        echo "variant=$variant"
        if [ "$danger_mode" = true ]; then
            echo "danger=true"
        fi
        if [ -n "$account_id" ]; then
            echo "account=$account_id"
        fi
    } > "$CONFIG_FILE"
    
    log_verbose "Saved configuration: variant=$variant, danger=$danger_mode, account=$account_id"
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        log_verbose "Loading configuration from $CONFIG_FILE"
        
        # Load variant
        SAVED_VARIANT=$(grep "^variant=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
        
        # Load danger setting
        SAVED_DANGER=$(grep "^danger=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
        if [ "$SAVED_DANGER" = "true" ]; then
            SAVED_DANGER=true
        else
            SAVED_DANGER=false
        fi
        
        # Load account setting
        SAVED_ACCOUNT=$(grep "^account=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
        
        log_verbose "Loaded: variant=$SAVED_VARIANT, danger=$SAVED_DANGER, account=$SAVED_ACCOUNT"
    else
        log_verbose "No configuration file found"
        SAVED_VARIANT=""
        SAVED_DANGER=false
        SAVED_ACCOUNT=""
    fi
}

auto_detect_variant() {
    log_verbose "Auto-detecting project variant..."
    
    if [ -f "go.mod" ] || [ -f "go.sum" ]; then
        echo "go"
    elif [ -f "Cargo.toml" ] || [ -f "Cargo.lock" ]; then
        echo "full"  # Rust needs full environment
    elif [ -f "pom.xml" ] || [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
        echo "full"  # Java needs full environment
    elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] || [ -f "Pipfile" ]; then
        echo "base"  # Python already in base
    elif [ -f "package.json" ]; then
        echo "base"  # Node.js already in base
    else
        echo "base"  # Default fallback
    fi
}

determine_variant() {
    if [ -n "$EXPLICIT_VARIANT" ]; then
        echo "$EXPLICIT_VARIANT"
    elif [ -n "$SAVED_VARIANT" ]; then
        log_verbose "Using saved variant: $SAVED_VARIANT"
        echo "$SAVED_VARIANT"
    else
        local detected=$(auto_detect_variant)
        log_verbose "Auto-detected variant: $detected"
        echo "$detected"
    fi
}

validate_variant() {
    local variant="$1"
    case "$variant" in
        base|go|full|cloud|k8s)
            return 0
            ;;
        *)
            log_error "Invalid variant: $variant"
            log_error "Available variants: base, go, full, cloud, k8s"
            return 1
            ;;
    esac
}

# --- Argument Parsing ---
REBUILD=false
CLEAN=false
CLEAN_ALL=false
INTERACTIVE_LOGIN=false
DANGER_MODE=false
SHELL_MODE=false
EXPLICIT_VARIANT=""
EXPLICIT_ACCOUNT=""
EXPLICIT_APIKEY=""
MOUNT_PATHS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_usage
            exit 0
            ;;
        --variant)
            if [[ -z "$2" ]]; then log_error "--variant requires a value"; exit 1; fi
            EXPLICIT_VARIANT="$2"
            shift 2
            ;;
        --account)
            if [[ -z "$2" ]]; then log_error "--account requires a value"; exit 1; fi
            EXPLICIT_ACCOUNT="$2"
            shift 2
            ;;
        --apikey)
            if [[ -z "$2" ]]; then log_error "--apikey requires a value"; exit 1; fi
            EXPLICIT_APIKEY="$2"
            shift 2
            ;;
        --mount)
            if [[ -z "$2" ]]; then log_error "--mount requires a path"; exit 1; fi
            MOUNT_PATHS+=("$2")
            shift 2
            ;;
        --list-variants|--list-accounts|--show-config|--verbose|-v|--rebuild|--clean|--clean-all|--interactive-login|--danger|--shell|--install|--uninstall)
            # Handle flags
            case $1 in
                --list-variants) SHOW_VARIANTS=true ;;
                --list-accounts) SHOW_ACCOUNTS=true ;;
                --show-config) SHOW_CONFIG=true ;;
                --verbose|-v) VERBOSE=true ;;
                --rebuild) REBUILD=true ;;
                --clean) CLEAN=true ;;
                --clean-all) CLEAN_ALL=true ;;
                --interactive-login) INTERACTIVE_LOGIN=true ;;
                --danger) DANGER_MODE=true ;;
                --shell) SHELL_MODE=true ;;
                --install) INSTALL=true ;;
                --uninstall) UNINSTALL=true ;;
            esac
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# --- Validate Explicit Variant First ---
if [ -n "$EXPLICIT_VARIANT" ]; then
    if ! validate_variant "$EXPLICIT_VARIANT"; then
        exit 1
    fi
fi

# --- Load Configuration ---
load_config

# --- Early Configuration Determination for Special Commands ---
VARIANT=${EXPLICIT_VARIANT:-${SAVED_VARIANT:-$(auto_detect_variant)}}

# --- Save Configuration if Explicit Options Were Provided ---
if [ -n "$EXPLICIT_VARIANT" ] || [ "$DANGER_MODE" = true ] || [ -n "$EXPLICIT_ACCOUNT" ]; then
    save_config "$VARIANT" "$DANGER_MODE" "${EXPLICIT_ACCOUNT:-$SAVED_ACCOUNT}"
fi

# --- Save API Key if Provided ---
if [ -n "$EXPLICIT_APIKEY" ]; then
    ACCOUNT_FOR_APIKEY="${EXPLICIT_ACCOUNT:-$SAVED_ACCOUNT}"
    save_api_key "$ACCOUNT_FOR_APIKEY" "$EXPLICIT_APIKEY"
    if [ -z "$EXPLICIT_VARIANT" ] && [ "$DANGER_MODE" = false ] && [ -z "$EXPLICIT_ACCOUNT" ] && [ "$#" -eq 0 ]; then
        exit 0
    fi
fi

# --- Handle Special Commands ---
if [ "$SHOW_VARIANTS" = true ]; then show_variants; exit 0; fi
if [ "$SHOW_ACCOUNTS" = true ]; then show_accounts; exit 0; fi
if [ "$SHOW_CONFIG" = true ]; then show_current_config; exit 0; fi
if [ "$INSTALL" = true ]; then install_script; exit 0; fi
if [ "$UNINSTALL" = true ]; then uninstall_script; exit 0; fi
if [ "$CLEAN_ALL" = true ]; then clean_all_containers; exit 0; fi

# --- Dependency Check ---
if ! command -v docker &> /dev/null; then
    log_error "Docker is not installed or not in your PATH. Please install Docker Desktop."
    exit 1
fi
log_verbose "Docker found: $(docker --version)"

# --- Architecture Detection ---
ARCHITECTURE=$(detect_architecture)
DOCKER_PLATFORM=$(get_docker_platform)

# --- Determine Names ---
IMAGE_NAME="$BASE_IMAGE_NAME-$VARIANT-$ARCHITECTURE"
PROJECT_HASH=$(echo "$(pwd)" | shasum -a 256 | cut -c1-8)
ACCOUNT_ID="${EXPLICIT_ACCOUNT:-$SAVED_ACCOUNT}"
CONTAINER_NAME="$BASE_CONTAINER_NAME-$VARIANT-$ARCHITECTURE-$PROJECT_HASH"
if [ -n "$ACCOUNT_ID" ]; then
    CONTAINER_NAME="${CONTAINER_NAME}-${ACCOUNT_ID}"
fi

log_verbose "Using variant: $VARIANT"
log_verbose "Image name: $IMAGE_NAME"
log_verbose "Container name: $CONTAINER_NAME"

# --- Apply Saved Danger Mode ---
if [ "$SAVED_DANGER" = true ] && [ "$DANGER_MODE" = false ]; then
    log_verbose "Applying saved danger mode setting"
    DANGER_MODE=true
fi

# --- Container Cleanup ---
if [ "$REBUILD" = true ]; then CLEAN=true; fi
if [ "$CLEAN" = true ]; then
    log_info "Cleaning up existing container..."
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        docker rm -f "$CONTAINER_NAME" &> /dev/null || true
        log_info "Container $CONTAINER_NAME removed."
    fi
fi

# --- Image Build Check ---
if [ "$REBUILD" = true ] || ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
    if [ "$REBUILD" = true ]; then
        log_info "Rebuilding Docker image '$IMAGE_NAME'..."
        docker rmi "$IMAGE_NAME" &> /dev/null || true
    else
        log_info "Docker image '$IMAGE_NAME' not found."
    fi
    
    if [ -f "Dockerfile" ]; then
        log_info "Building variant: $VARIANT..."
        docker build --target "$VARIANT" -t "$IMAGE_NAME" .
        log_info "Image '$IMAGE_NAME' built successfully."
    else
        log_error "Dockerfile not found. Please run from the project root."
        exit 1
    fi
fi

# --- Container Lifecycle Management ---
if ! docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    log_info "Creating and starting new container '${CONTAINER_NAME}'..."
    
    USER_UID=$(id -u)
    USER_GID=$(id -g)
    
    DOCKER_RUN_ARGS=(
        -d
        --name "$CONTAINER_NAME"
        -v "$(pwd):/app"
        -v "${HOME}/.kube:/home/claude/.kube:ro"
        -v "${HOME}/.gitconfig:/home/claude/.gitconfig:ro"
        -v "/var/run/docker.sock:/var/run/docker.sock"
        # The --user flag is set in the Dockerfile, not here.
    )
    
    # ... (rest of the mounting and auth logic remains the same)
    # Setup account-specific Claude directory structure
    ACCOUNT_ID="${EXPLICIT_ACCOUNT:-$SAVED_ACCOUNT}"
    CLAUDE_ACCOUNT_DIR=$(get_claude_account_dir "$ACCOUNT_ID")
    
    if [ -n "$CLAUDE_ACCOUNT_DIR" ]; then
        if [ ! -d "$CLAUDE_ACCOUNT_DIR" ]; then
            mkdir -p "$CLAUDE_ACCOUNT_DIR"
            if [ -f "${HOME}/.claude.json" ]; then cp "${HOME}/.claude.json" "$CLAUDE_ACCOUNT_DIR/.claude.json"; fi
            if [ -d "${HOME}/.claude" ]; then cp -r "${HOME}/.claude" "$CLAUDE_ACCOUNT_DIR/.claude"; fi
        fi
        if [ -f "$CLAUDE_ACCOUNT_DIR/.claude.json" ]; then DOCKER_RUN_ARGS+=("-v" "$CLAUDE_ACCOUNT_DIR/.claude.json:/home/claude/.claude.json"); fi
        if [ -d "$CLAUDE_ACCOUNT_DIR/.claude" ]; then DOCKER_RUN_ARGS+=("-v" "$CLAUDE_ACCOUNT_DIR/.claude:/home/claude/.claude"); fi
    else
        if [ -f "${HOME}/.claude.json" ]; then DOCKER_RUN_ARGS+=("-v" "${HOME}/.claude.json:/home/claude/.claude.json"); fi
        if [ -d "${HOME}/.claude" ]; then DOCKER_RUN_ARGS+=("-v" "${HOME}/.claude:/home/claude/.claude"); fi
    fi
    
    update_claude_settings_for_mounts
    
    for mount_path in "${MOUNT_PATHS[@]}"; do
        expanded_path="${mount_path/#\~/$HOME}"
        if [[ "$expanded_path" != /* ]]; then expanded_path="$(pwd)/$expanded_path"; fi
        if [ -d "$expanded_path" ]; then
            DOCKER_RUN_ARGS+=("-v" "$expanded_path:/mnt/$(basename "$expanded_path")")
        else
            log_warning "Mount path does not exist: $expanded_path"
        fi
    done
    
    if [ "$INTERACTIVE_LOGIN" != true ]; then
        PROJECT_API_KEY_FILE=$(get_api_key_file "$ACCOUNT_ID")
        if [ -f "$PROJECT_API_KEY_FILE" ]; then
            DOCKER_RUN_ARGS+=("--env-file" "$PROJECT_API_KEY_FILE")
        elif [ -f "${HOME}/.env" ]; then
            DOCKER_RUN_ARGS+=("--env-file" "${HOME}/.env")
        fi
    fi
    
    log_verbose "Docker run command: docker run ${DOCKER_RUN_ARGS[*]} $IMAGE_NAME"
    docker run "${DOCKER_RUN_ARGS[@]}" "$IMAGE_NAME" > /dev/null
fi

if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
    log_info "Starting stopped container '${CONTAINER_NAME}'..."
    docker start "$CONTAINER_NAME" > /dev/null
fi

# --- Container Health Check ---
log_verbose "Checking container health..."
for i in {1..5}; do
    if docker exec "$CONTAINER_NAME" echo "Container is responsive" &> /dev/null; then
        log_verbose "Container health check passed"
        break
    fi
    if [ $i -eq 5 ]; then log_error "Container is not responding."; exit 1; fi
    sleep 1
done

# --- Attach to the Container ---
CLAUDE_CMD="claude"
if [ "$DANGER_MODE" = true ]; then
    CLAUDE_CMD="$CLAUDE_CMD --dangerously-skip-permissions"
fi

# The container's entrypoint.sh handles user and docker socket setup.
# We can now exec directly without specifying the user.
if [ "$SHELL_MODE" = true ]; then
    log_info "Launching bash shell in container..."
    docker exec -it "$CONTAINER_NAME" bash-with-prompt
else
    log_info "Launching Claude CLI in container..."
    docker exec -it "$CONTAINER_NAME" $CLAUDE_CMD
fi
