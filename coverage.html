
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>claude-reactor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">claude-reactor/cmd/claude-reactor/main.go (14.6%)</option>
				
				<option value="file1">claude-reactor/internal/architecture/detector.go (67.6%)</option>
				
				<option value="file2">claude-reactor/internal/config/manager.go (93.0%)</option>
				
				<option value="file3">claude-reactor/internal/container.go (93.8%)</option>
				
				<option value="file4">claude-reactor/internal/logging/logger.go (93.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "claude-reactor/internal"
        "claude-reactor/pkg"
)

var (
        // Version information - will be set during build
        Version   = "dev"
        GitCommit = "unknown"
        BuildDate = "unknown"
)

func main() <span class="cov0" title="0">{
        if err := Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// Execute runs the root command
func Execute() error <span class="cov0" title="0">{
        ctx := context.Background()
        
        // Initialize application container
        app, err := internal.NewAppContainer()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize application: %w", err)
        }</span>

        <span class="cov0" title="0">rootCmd := newRootCmd(app)
        return rootCmd.ExecuteContext(ctx)</span>
}

func newRootCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var rootCmd = &amp;cobra.Command{
                Use:   "claude-reactor",
                Short: "Claude CLI in Docker - Modern containerization for Claude development",
                Long: `Claude-Reactor provides a professional, modular Docker containerization system 
for Claude CLI development workflows. It transforms the basic Claude CLI into a 
comprehensive development environment with intelligent automation, multi-language 
support, and production-ready tooling.`,
                Version: fmt.Sprintf("%s (commit: %s, built: %s)", Version, GitCommit, BuildDate),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        // Handle installation flags (Phase 0.2)
                        if install, _ := cmd.Flags().GetBool("install"); install </span><span class="cov0" title="0">{
                                if err := handleInstallation(cmd, app, true); err != nil </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Installation failed: %v\n", err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        
                        <span class="cov8" title="1">if uninstall, _ := cmd.Flags().GetBool("uninstall"); uninstall </span><span class="cov0" title="0">{
                                if err := handleInstallation(cmd, app, false); err != nil </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Uninstallation failed: %v\n", err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        
                        // Handle legacy flags for backward compatibility
                        <span class="cov8" title="1">if listVariants, _ := cmd.Flags().GetBool("list-variants"); listVariants </span><span class="cov8" title="1">{
                                handleLegacyListVariants(cmd, app)
                                return
                        }</span>
                        
                        // Check for variant flag and validate it
                        <span class="cov8" title="1">variant, _ := cmd.Flags().GetString("variant")
                        if variant != "" </span><span class="cov8" title="1">{
                                // Validate the variant
                                variants := []string{"base", "go", "full", "cloud", "k8s"}
                                validVariant := false
                                for _, v := range variants </span><span class="cov8" title="1">{
                                        if v == variant </span><span class="cov8" title="1">{
                                                validVariant = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !validVariant </span><span class="cov0" title="0">{
                                        cmd.PrintErrf("Error: invalid variant '%s'. Available variants: %s\n", 
                                                variant, strings.Join(variants, ", "))
                                        os.Exit(1)
                                }</span>
                                
                                // Save the variant to configuration (for backward compatibility)
                                <span class="cov8" title="1">config := &amp;pkg.Config{
                                        Variant:     variant,
                                        Account:     "",
                                        DangerMode:  false,
                                        ProjectPath: "",
                                        Metadata:    make(map[string]string),
                                }
                                _ = app.ConfigMgr.SaveConfig(config)</span>
                        }
                        
                        <span class="cov8" title="1">if showConfig, _ := cmd.Flags().GetBool("show-config"); showConfig </span><span class="cov8" title="1">{
                                handleLegacyShowConfig(cmd, app)
                                return
                        }</span>
                        
                        // Default action - show help or run with default config
                        <span class="cov8" title="1">cmd.Help()</span>
                },
        }

        // Global flags
        <span class="cov8" title="1">rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Enable verbose output")
        rootCmd.PersistentFlags().String("log-level", "info", "Set log level (debug, info, warn, error)")
        
        // Legacy compatibility flags (hidden from help)
        rootCmd.Flags().Bool("list-variants", false, "List available container variants")
        rootCmd.Flags().Bool("show-config", false, "Show current configuration")
        rootCmd.Flags().String("variant", "", "Container variant (for compatibility)")
        rootCmd.Flags().MarkHidden("list-variants")
        rootCmd.Flags().MarkHidden("show-config")
        rootCmd.Flags().MarkHidden("variant")
        
        // Installation flags (Phase 0.2)
        rootCmd.Flags().Bool("install", false, "Install claude-reactor to system PATH (/usr/local/bin)")
        rootCmd.Flags().Bool("uninstall", false, "Remove claude-reactor from system PATH")

        // Add subcommands
        rootCmd.AddCommand(
                newRunCmd(app),
                newBuildCmd(app),
                newConfigCmd(app),
                newCleanCmd(app),
                newDevContainerCmd(app),
                newTemplateCmd(app),
                newDependencyCmd(app),
                newHotReloadCmd(app),
                newDebugCmd(app),
        )

        return rootCmd</span>
}

func newRunCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var runCmd = &amp;cobra.Command{
                Use:   "run",
                Short: "Start and connect to a Claude CLI container",
                Long: `Start and connect to a Claude CLI container with the specified variant.
This will auto-detect project type, build the container if needed, and connect you
to the Claude CLI running inside the container.

Examples:
  claude-reactor run                    # Auto-detect variant and run
  claude-reactor run --variant go       # Use Go toolchain variant
  claude-reactor run --shell            # Launch interactive shell instead
  claude-reactor run --danger           # Enable danger mode (skip permissions)
  claude-reactor run --account work     # Use specific account configuration
  claude-reactor run --persist=false    # Remove container when finished
  
  # Registry control (v2 images)
  claude-reactor run --dev              # Force local build (disable registry)
  claude-reactor run --registry-off     # Disable registry completely
  claude-reactor run --pull-latest      # Force pull latest from registry
  claude-reactor run --continue=false   # Disable conversation continuation`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runContainer(cmd, app)
                }</span>,
        }

        // Run command flags
        <span class="cov8" title="1">runCmd.Flags().StringP("variant", "", "", "Container variant (base, go, full, cloud, k8s)")
        runCmd.Flags().StringP("account", "", "", "Claude account to use")
        runCmd.Flags().BoolP("danger", "", false, "Enable danger mode (--dangerously-skip-permissions)")
        runCmd.Flags().BoolP("shell", "", false, "Launch shell instead of Claude CLI")
        runCmd.Flags().StringSliceP("mount", "m", []string{}, "Additional mount points (can be used multiple times)")
        runCmd.Flags().BoolP("persist", "", true, "Keep container running after exit (default: true)")
        runCmd.Flags().BoolP("no-mounts", "", false, "Skip mounting directories (for testing)")
        
        // Registry flags (Phase 0.1)
        runCmd.Flags().BoolP("dev", "", false, "Force local build (disable registry pulls)")
        runCmd.Flags().BoolP("registry-off", "", false, "Disable registry completely")
        runCmd.Flags().BoolP("pull-latest", "", false, "Force pull latest from registry")
        runCmd.Flags().BoolP("continue", "", true, "Enable conversation continuation (default: true)")

        return runCmd</span>
}

func newBuildCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var buildCmd = &amp;cobra.Command{
                Use:   "build [variant]",
                Short: "Build container images",
                Long: `Build Docker container images for the specified variant or all variants.
This will build the multi-stage Dockerfile with architecture-aware optimizations.

Examples:
  claude-reactor build               # Build base variant
  claude-reactor build go            # Build Go toolchain variant
  claude-reactor build --rebuild     # Force rebuild of base variant
  claude-reactor build full --rebuild # Force rebuild of full variant`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        app.Logger.Info("🔨 Building container images...")
                        
                        variant := "base"
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                variant = args[0]
                        }</span>
                        
                        <span class="cov0" title="0">rebuild, _ := cmd.Flags().GetBool("rebuild")
                        app.Logger.Infof("📋 Building variant: %s, force rebuild: %t", variant, rebuild)
                        
                        if rebuild </span><span class="cov0" title="0">{
                                app.Logger.Info("⚡ Force rebuild enabled - removing existing images first")
                        }</span>
                        
                        // Get Docker platform from architecture detector
                        <span class="cov0" title="0">app.Logger.Info("🔧 Detecting system architecture...")
                        platform, err := app.ArchDetector.GetDockerPlatform()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to determine Docker platform: %w. Architecture may not be supported", err)
                        }</span>
                        <span class="cov0" title="0">app.Logger.Infof("🐳 Building for platform: %s", platform)
                        
                        // Use Docker manager to build image
                        ctx := cmd.Context()
                        app.Logger.Info("⏳ This may take several minutes for first-time build...")
                        
                        if rebuild </span><span class="cov0" title="0">{
                                err = app.DockerMgr.RebuildImage(ctx, variant, platform, true)
                        }</span> else<span class="cov0" title="0"> {
                                err = app.DockerMgr.BuildImage(ctx, variant, platform)
                        }</span>
                        
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to build image: %w. Try running 'docker system prune' to free space", err)
                        }</span>
                        
                        <span class="cov0" title="0">app.Logger.Info("✅ Image build completed successfully!")
                        app.Logger.Info("💡 You can now run 'claude-reactor run' to start the container")
                        return nil</span>
                },
        }

        <span class="cov8" title="1">buildCmd.Flags().BoolP("rebuild", "", false, "Force rebuild of existing images")

        return buildCmd</span>
}

func newConfigCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var configCmd = &amp;cobra.Command{
                Use:   "config",
                Short: "Configuration management",
                Long:  "Manage claude-reactor configuration settings.",
        }

        // Config show subcommand with enhanced display
        showCmd := &amp;cobra.Command{
                Use:   "show",
                Short: "Show current configuration with registry status",
                Long: `Display comprehensive configuration information including:
- Project configuration (variant, account, danger mode)
- Registry configuration and status
- System paths and architecture details
- Raw configuration file contents

Examples:
  claude-reactor config show           # Show basic configuration
  claude-reactor config show --raw     # Include raw config file contents
  claude-reactor config show --verbose # Show detailed system information`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        return showEnhancedConfig(cmd, app)
                }</span>,
        }
        
        // Add flags to show subcommand
        <span class="cov8" title="1">showCmd.Flags().Bool("raw", false, "Include raw configuration file contents")
        showCmd.Flags().Bool("verbose", false, "Show detailed system information")

        // Add config subcommands
        configCmd.AddCommand(
                showCmd,
                &amp;cobra.Command{
                        Use:   "validate",
                        Short: "Validate configuration",
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                                config, err := app.ConfigMgr.LoadConfig()
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to load configuration: %w", err)
                                }</span>
                                
                                <span class="cov8" title="1">if err := app.ConfigMgr.ValidateConfig(config); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("configuration validation failed: %w", err)
                                }</span>
                                
                                <span class="cov8" title="1">cmd.Println("Configuration is valid ✓")
                                return nil</span>
                        },
                },
        )

        <span class="cov8" title="1">return configCmd</span>
}

func newCleanCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var cleanCmd = &amp;cobra.Command{
                Use:   "clean",
                Short: "Clean up containers and images",
                Long: `Remove stopped containers and optionally clean up images.
Use --all to remove all claude-reactor containers across all accounts.

Examples:
  claude-reactor clean                # Remove current project container
  claude-reactor clean --all          # Remove all claude-reactor containers
  claude-reactor clean --images       # Also remove project images
  claude-reactor clean --all --images # Remove everything (containers + images)`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return cleanContainers(cmd, app)
                }</span>,
        }

        <span class="cov8" title="1">cleanCmd.Flags().BoolP("all", "", false, "Clean all claude-reactor containers")
        cleanCmd.Flags().BoolP("images", "", false, "Also remove images")

        return cleanCmd</span>
}

func newDebugCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var debugCmd = &amp;cobra.Command{
                Use:   "debug",
                Short: "Debug information and troubleshooting",
                Long:  "Provide debug information and troubleshooting tools.",
        }

        debugCmd.AddCommand(
                &amp;cobra.Command{
                        Use:   "info",
                        Short: "Show system information",
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                                app.Logger.Info("=== Claude-Reactor Debug Info ===")
                                
                                // Architecture information
                                arch, err := app.ArchDetector.GetHostArchitecture()
                                if err != nil </span><span class="cov0" title="0">{
                                        app.Logger.Errorf("Failed to detect architecture: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        cmd.Printf("Host Architecture: %s\n", arch)
                                }</span>
                                
                                <span class="cov0" title="0">platform, err := app.ArchDetector.GetDockerPlatform()
                                if err != nil </span><span class="cov0" title="0">{
                                        app.Logger.Errorf("Failed to get Docker platform: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        cmd.Printf("Docker Platform: %s\n", platform)
                                }</span>
                                
                                <span class="cov0" title="0">cmd.Printf("Multi-arch Support: %t\n", app.ArchDetector.IsMultiArchSupported())
                                
                                // Version information
                                cmd.Printf("Version: %s\n", Version)
                                cmd.Printf("Git Commit: %s\n", GitCommit)
                                cmd.Printf("Build Date: %s\n", BuildDate)
                                
                                // Docker connectivity test
                                ctx := cmd.Context()
                                _, dockerErr := app.DockerMgr.IsContainerRunning(ctx, "test-connection")
                                if dockerErr != nil </span><span class="cov0" title="0">{
                                        cmd.Printf("Docker Connection: ❌ Failed (%v)\n", dockerErr)
                                }</span> else<span class="cov0" title="0"> {
                                        cmd.Printf("Docker Connection: ✅ Connected\n")
                                }</span>
                                
                                <span class="cov0" title="0">return nil</span>
                        },
                },
        )

        <span class="cov8" title="1">return debugCmd</span>
}

// handleLegacyListVariants handles the --list-variants flag for backward compatibility
func handleLegacyListVariants(cmd *cobra.Command, app *pkg.AppContainer) <span class="cov8" title="1">{
        cmd.Println("Available container variants:")
        variants := []string{"base", "go", "full", "cloud", "k8s"}
        for _, variant := range variants </span><span class="cov8" title="1">{
                cmd.Printf("  %s\n", variant)
        }</span>
}

// handleLegacyShowConfig handles the --show-config flag for backward compatibility
func handleLegacyShowConfig(cmd *cobra.Command, app *pkg.AppContainer) <span class="cov8" title="1">{
        config, err := app.ConfigMgr.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                cmd.Printf("Error loading configuration: %v\n", err)
                return
        }</span>
        
        <span class="cov8" title="1">cmd.Printf("Current Configuration:\n")
        cmd.Printf("  Variant: %s\n", config.Variant)
        cmd.Printf("  Account: %s\n", config.Account)
        cmd.Printf("  Danger Mode: %t\n", config.DangerMode)
        cmd.Printf("  Project Path: %s\n", config.ProjectPath)</span>
}

// runContainer implements the core run command logic
func runContainer(cmd *cobra.Command, app *pkg.AppContainer) error <span class="cov0" title="0">{
        ctx := cmd.Context()
        
        // Parse command flags
        variant, _ := cmd.Flags().GetString("variant")
        account, _ := cmd.Flags().GetString("account")
        danger, _ := cmd.Flags().GetBool("danger")
        shell, _ := cmd.Flags().GetBool("shell")
        mounts, _ := cmd.Flags().GetStringSlice("mount")
        persist, _ := cmd.Flags().GetBool("persist")
        noMounts, _ := cmd.Flags().GetBool("no-mounts")
        
        // Registry flags (Phase 0.1)
        devMode, _ := cmd.Flags().GetBool("dev")
        registryOff, _ := cmd.Flags().GetBool("registry-off")
        pullLatest, _ := cmd.Flags().GetBool("pull-latest")
        
        // Conversation control (Phase 0.3)
        continueConversation, _ := cmd.Flags().GetBool("continue")
        
        app.Logger.Info("🚀 Starting Claude CLI container...")
        
        // Step 1: Load or create configuration
        app.Logger.Info("📋 Loading configuration...")
        config, err := app.ConfigMgr.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w. Try running 'claude-reactor config validate' to check your setup", err)
        }</span>
        
        // Override config with command-line flags
        <span class="cov0" title="0">if variant != "" </span><span class="cov0" title="0">{
                config.Variant = variant
        }</span>
        <span class="cov0" title="0">if account != "" </span><span class="cov0" title="0">{
                config.Account = account
        }</span>
        <span class="cov0" title="0">config.DangerMode = danger
        
        // Auto-detect variant if not specified
        if config.Variant == "" </span><span class="cov0" title="0">{
                app.Logger.Info("🔍 Auto-detecting project type...")
                detectedVariant, err := app.ConfigMgr.AutoDetectVariant("")
                if err != nil </span><span class="cov0" title="0">{
                        app.Logger.Warnf("Failed to auto-detect variant: %v", err)
                        app.Logger.Info("💡 Defaulting to 'base' variant. Use --variant flag to specify manually")
                        config.Variant = "base"
                }</span> else<span class="cov0" title="0"> {
                        config.Variant = detectedVariant
                        app.Logger.Infof("✅ Auto-detected variant: %s", config.Variant)
                }</span>
        }
        
        // Validate configuration
        <span class="cov0" title="0">app.Logger.Info("✅ Validating configuration...")
        if err := app.ConfigMgr.ValidateConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w. Try using --variant with one of: base, go, full, cloud, k8s", err)
        }</span>
        
        // Log registry configuration if relevant
        <span class="cov0" title="0">if devMode </span><span class="cov0" title="0">{
                app.Logger.Info("🔨 Registry: Dev mode enabled - forcing local builds")
        }</span> else<span class="cov0" title="0"> if registryOff </span><span class="cov0" title="0">{
                app.Logger.Info("🔨 Registry: Registry disabled - using local builds only")
        }</span> else<span class="cov0" title="0"> if pullLatest </span><span class="cov0" title="0">{
                app.Logger.Info("📦 Registry: Force pulling latest images from registry")
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("📋 Configuration: variant=%s, account=%s, danger=%t, shell=%t, persist=%t", 
                config.Variant, config.Account, config.DangerMode, shell, persist)
        
        // Step 2: Generate container and image names
        app.Logger.Info("🔧 Detecting system architecture...")
        arch, err := app.ArchDetector.GetHostArchitecture()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect architecture: %w. Your system may not be supported", err)
        }</span>
        
        <span class="cov0" title="0">containerName := app.DockerMgr.GenerateContainerName("", config.Variant, arch, config.Account)
        app.Logger.Infof("🏷️ Container name: %s", containerName)
        
        // Step 3: Check existing container status
        app.Logger.Info("🔍 Checking existing containers...")
        status, err := app.DockerMgr.GetContainerStatus(ctx, containerName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check container status: %w. Check if Docker daemon is running", err)
        }</span>
        
        <span class="cov0" title="0">var containerID string
        
        if status.Exists &amp;&amp; status.Running </span><span class="cov0" title="0">{
                app.Logger.Infof("✅ Container %s is already running", containerName)
                containerID = status.ID
        }</span> else<span class="cov0" title="0"> {
                // Step 4: Build image if needed
                app.Logger.Info("🐳 Preparing Docker environment...")
                platform, err := app.ArchDetector.GetDockerPlatform()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get Docker platform: %w. Architecture detection failed", err)
                }</span>
                
                <span class="cov0" title="0">imageName := app.DockerMgr.GetImageName(config.Variant, arch)
                app.Logger.Infof("🔨 Building image if needed: %s", imageName)
                app.Logger.Info("⏳ This may take a few minutes for first-time setup...")
                
                // Build image with registry support (Phase 0.1)
                err = app.DockerMgr.BuildImageWithRegistry(ctx, config.Variant, platform, devMode, registryOff, pullLatest)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to build image: %w. Try running 'docker system prune' to free space or check your Dockerfile", err)
                }</span>
                
                // Step 5: Create container configuration
                <span class="cov0" title="0">containerConfig := &amp;pkg.ContainerConfig{
                        Image:       imageName,
                        Name:        containerName,
                        Variant:     config.Variant,
                        Platform:    platform,
                        Interactive: true,
                        TTY:         true,
                        Remove:      false, // Don't auto-remove - we manage lifecycle
                }
                
                // Add mounts (skip if requested for testing)
                if !noMounts </span><span class="cov0" title="0">{
                        app.Logger.Info("📁 Configuring container mounts...")
                        err = addMountsToContainer(app, containerConfig, config.Account, mounts)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to configure mounts: %w. Check that source directories exist and are accessible", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        app.Logger.Info("🚫 Skipping mounts due to --no-mounts flag")
                        // Set empty mounts to prevent default mount creation
                        containerConfig.Mounts = []pkg.Mount{}
                }</span>
                
                // Step 6: Start container
                <span class="cov0" title="0">if status.Exists </span><span class="cov0" title="0">{
                        app.Logger.Infof("🔄 Starting existing container: %s", containerName)
                        app.Logger.Info("💡 Container already exists, reusing it...")
                        // Container exists but isn't running - start it
                        // TODO: Implement StartExistingContainer method or use Docker SDK directly
                        containerID = status.ID
                }</span> else<span class="cov0" title="0"> {
                        app.Logger.Infof("🏗️ Creating new container: %s", containerName)
                        app.Logger.Info("⚡ Starting container with your configuration...")
                        containerID, err = app.DockerMgr.StartContainer(ctx, containerConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start container: %w. Check Docker daemon is running and try 'docker system prune'", err)
                        }</span>
                        <span class="cov0" title="0">app.Logger.Info("✅ Container created and started successfully!")</span>
                }
        }
        
        // Step 7: Attach to container
        <span class="cov0" title="0">var command []string
        if shell </span><span class="cov0" title="0">{
                command = []string{"/bin/bash"}
                app.Logger.Info("🐚 Launching interactive shell in container...")
                app.Logger.Info("💡 Type 'claude' to start Claude CLI, or 'exit' to leave the container")
        }</span> else<span class="cov0" title="0"> {
                // Build Claude CLI command with flags
                command = []string{"claude"}
                
                if config.DangerMode </span><span class="cov0" title="0">{
                        command = append(command, "--dangerously-skip-permissions")
                        app.Logger.Info("🤖 Launching Claude CLI in DANGER MODE...")
                        app.Logger.Info("⚠️  Danger mode bypasses permission checks - use with caution!")
                }</span> else<span class="cov0" title="0"> {
                        app.Logger.Info("🤖 Launching Claude CLI in container...")
                }</span>
                
                // Conversation control (Phase 0.3)
                <span class="cov0" title="0">if !continueConversation </span><span class="cov0" title="0">{
                        command = append(command, "--no-conversation-continuation")
                        app.Logger.Info("💬 Conversation continuation disabled")
                }</span> else<span class="cov0" title="0"> {
                        app.Logger.Debug("💬 Conversation continuation enabled (default)")
                }</span>
        }
        
        // Attach to container
        <span class="cov0" title="0">err = app.DockerMgr.AttachToContainer(ctx, containerName, command, true)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach to container: %w. Try using 'docker exec -it %s %s' as fallback", err, containerName, strings.Join(command, " "))
        }</span>
        
        // Step 8: Handle container persistence
        <span class="cov0" title="0">if !persist </span><span class="cov0" title="0">{
                app.Logger.Info("🧹 Stopping container due to --persist=false...")
                if err := app.DockerMgr.StopContainer(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                        app.Logger.Warnf("Failed to stop container: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                app.Logger.Info("💾 Container will remain running (use 'claude-reactor clean' to stop)")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// addMountsToContainer configures the container mounts
func addMountsToContainer(app *pkg.AppContainer, containerConfig *pkg.ContainerConfig, account string, userMounts []string) error <span class="cov0" title="0">{
        // Add default mounts (project directory, Claude config)
        projectDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>
        
        // Project mount - avoid circular mount if we're already in /app
        <span class="cov0" title="0">targetPath := "/app"
        if projectDir == "/app" </span><span class="cov0" title="0">{
                targetPath = "/workspace"  // Use different path to avoid circular mount
        }</span>
        
        <span class="cov0" title="0">err = app.MountMgr.AddMountToConfig(containerConfig, projectDir, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add project mount: %w", err)
        }</span>
        <span class="cov0" title="0">app.Logger.Infof("📁 Project mount: %s -&gt; %s", projectDir, targetPath)
        
        // Claude config mount
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">claudeConfigPath := filepath.Join(homeDir, ".claude")
        if account != "" &amp;&amp; account != "default" </span><span class="cov0" title="0">{
                claudeConfigPath = app.AuthMgr.GetAccountConfigPath(account)
        }</span>
        
        // Only mount if config exists
        <span class="cov0" title="0">if _, err := os.Stat(claudeConfigPath); err == nil </span><span class="cov0" title="0">{
                err = app.MountMgr.AddMountToConfig(containerConfig, claudeConfigPath, "/home/claude/.claude")
                if err != nil </span><span class="cov0" title="0">{
                        app.Logger.Warnf("Failed to add Claude config mount: %v", err)
                }</span>
        }
        
        // Add user-specified mounts
        <span class="cov0" title="0">for _, mountPath := range userMounts </span><span class="cov0" title="0">{
                validatedPath, err := app.MountMgr.ValidateMountPath(mountPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid mount path '%s': %w", mountPath, err)
                }</span>
                
                // Generate target path (mount to /mnt/basename)
                <span class="cov0" title="0">targetPath := "/mnt/" + filepath.Base(validatedPath)
                err = app.MountMgr.AddMountToConfig(containerConfig, validatedPath, targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add user mount '%s': %w", mountPath, err)
                }</span>
                
                <span class="cov0" title="0">app.Logger.Infof("📁 Added mount: %s -&gt; %s", validatedPath, targetPath)</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// cleanContainers implements the clean command logic
func cleanContainers(cmd *cobra.Command, app *pkg.AppContainer) error <span class="cov0" title="0">{
        ctx := cmd.Context()
        
        all, _ := cmd.Flags().GetBool("all")
        images, _ := cmd.Flags().GetBool("images")
        
        app.Logger.Info("🧹 Cleaning up containers...")
        
        if all </span><span class="cov0" title="0">{
                // Clean all claude-reactor containers across all accounts
                app.Logger.Info("🗑️ Removing all claude-reactor containers across all accounts...")
                app.Logger.Info("⏳ This will stop and remove all running claude-reactor containers...")
                err := app.DockerMgr.CleanAllContainers(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clean all containers: %w. Try running 'docker container prune' manually", err)
                }</span>
                <span class="cov0" title="0">app.Logger.Info("✅ All claude-reactor containers removed successfully")</span>
        } else<span class="cov0" title="0"> {
                // Clean only current project/account container
                app.Logger.Info("🔍 Loading current configuration to identify container...")
                config, err := app.ConfigMgr.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load configuration: %w. Try running 'claude-reactor config validate' to check setup", err)
                }</span>
                
                // Auto-detect variant if needed
                <span class="cov0" title="0">if config.Variant == "" </span><span class="cov0" title="0">{
                        app.Logger.Info("🔍 Auto-detecting project type...")
                        detectedVariant, err := app.ConfigMgr.AutoDetectVariant("")
                        if err != nil </span><span class="cov0" title="0">{
                                app.Logger.Warnf("Failed to auto-detect variant: %v", err)
                                app.Logger.Info("💡 Defaulting to 'base' variant")
                                config.Variant = "base"
                        }</span> else<span class="cov0" title="0"> {
                                config.Variant = detectedVariant
                        }</span>
                }
                
                <span class="cov0" title="0">arch, err := app.ArchDetector.GetHostArchitecture()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to detect architecture: %w. System may not be supported", err)
                }</span>
                
                <span class="cov0" title="0">containerName := app.DockerMgr.GenerateContainerName("", config.Variant, arch, config.Account)
                app.Logger.Infof("🗑️ Removing container for current project: %s", containerName)
                
                err = app.DockerMgr.CleanContainer(ctx, containerName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clean container %s: %w. Try 'docker ps' to check container status", containerName, err)
                }</span>
                <span class="cov0" title="0">app.Logger.Info("✅ Project container removed successfully")</span>
        }
        
        // Clean images if requested
        <span class="cov0" title="0">if images </span><span class="cov0" title="0">{
                if all </span><span class="cov0" title="0">{
                        app.Logger.Info("🗑️ Cleaning all claude-reactor images...")
                        app.Logger.Info("⏳ This will remove all cached claude-reactor images...")
                }</span> else<span class="cov0" title="0"> {
                        app.Logger.Info("🗑️ Cleaning current project claude-reactor images...")
                }</span>
                
                <span class="cov0" title="0">err := app.DockerMgr.CleanImages(ctx, all)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clean images: %w. Try running 'docker image prune' manually", err)
                }</span>
                
                <span class="cov0" title="0">app.Logger.Info("✅ Image cleanup completed successfully")
                app.Logger.Info("💡 Images will be rebuilt automatically on next run")</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// handleInstallation manages system installation and uninstallation (Phase 0.2)
func handleInstallation(cmd *cobra.Command, app *pkg.AppContainer, install bool) error <span class="cov0" title="0">{
        const installPath = "/usr/local/bin/claude-reactor"
        
        if install </span><span class="cov0" title="0">{
                // Installation process
                app.Logger.Info("🔧 Installing claude-reactor to system PATH...")
                
                // Get current executable path
                execPath, err := os.Executable()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to determine executable path: %w", err)
                }</span>
                
                <span class="cov0" title="0">app.Logger.Infof("📋 Source: %s", execPath)
                app.Logger.Infof("🎯 Target: %s", installPath)
                
                // Check if we need sudo
                if err := checkWritePermissions("/usr/local/bin"); err != nil </span><span class="cov0" title="0">{
                        app.Logger.Warn("⚠️  Installation requires sudo permissions for /usr/local/bin")
                        app.Logger.Info("💡 You may be prompted for your password...")
                        
                        // Use sudo to copy the binary
                        err := runWithSudo("cp", execPath, installPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to install with sudo: %w", err)
                        }</span>
                        
                        // Make executable
                        <span class="cov0" title="0">err = runWithSudo("chmod", "+x", installPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to make executable with sudo: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Direct copy (no sudo needed)
                        err := copyFile(execPath, installPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy binary: %w", err)
                        }</span>
                        
                        // Make executable
                        <span class="cov0" title="0">err = os.Chmod(installPath, 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to make executable: %w", err)
                        }</span>
                }
                
                <span class="cov0" title="0">app.Logger.Info("✅ claude-reactor installed successfully!")
                app.Logger.Info("💡 You can now use 'claude-reactor' from anywhere in your terminal")
                app.Logger.Info("🧪 Test with: claude-reactor --version")</span>
                
        } else<span class="cov0" title="0"> {
                // Uninstallation process
                app.Logger.Info("🗑️ Removing claude-reactor from system PATH...")
                
                // Check if file exists
                if _, err := os.Stat(installPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        app.Logger.Info("✅ claude-reactor is not installed in system PATH")
                        return nil
                }</span>
                
                // Check if we need sudo
                <span class="cov0" title="0">if err := checkWritePermissions("/usr/local/bin"); err != nil </span><span class="cov0" title="0">{
                        app.Logger.Warn("⚠️  Uninstallation requires sudo permissions for /usr/local/bin")
                        app.Logger.Info("💡 You may be prompted for your password...")
                        
                        err := runWithSudo("rm", "-f", installPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to uninstall with sudo: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Direct removal (no sudo needed)
                        err := os.Remove(installPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to remove binary: %w", err)
                        }</span>
                }
                
                <span class="cov0" title="0">app.Logger.Info("✅ claude-reactor removed from system PATH")
                app.Logger.Info("💡 Local binary is still available at the original location")</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// checkWritePermissions checks if we can write to the target directory
func checkWritePermissions(dir string) error <span class="cov0" title="0">{
        // Try to create a temporary file to test permissions
        testFile := filepath.Join(dir, ".claude-reactor-test")
        file, err := os.Create(testFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">file.Close()
        os.Remove(testFile)
        return nil</span>
}

// runWithSudo executes a command with sudo
func runWithSudo(command string, args ...string) error <span class="cov0" title="0">{
        allArgs := append([]string{command}, args...)
        cmd := exec.Command("sudo", allArgs...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Stdin = os.Stdin
        return cmd.Run()
}</span>

// copyFile copies a file from src to dst
func copyFile(src, dst string) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()
        
        destFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()
        
        _, err = io.Copy(destFile, sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return destFile.Sync()</span>
}

// showEnhancedConfig displays comprehensive configuration information (Phase 0.4)
func showEnhancedConfig(cmd *cobra.Command, app *pkg.AppContainer) error <span class="cov8" title="1">{
        // Parse flags
        showRaw, _ := cmd.Flags().GetBool("raw")
        verbose, _ := cmd.Flags().GetBool("verbose")
        
        // Load current configuration
        config, err := app.ConfigMgr.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        
        // Basic configuration
        <span class="cov8" title="1">cmd.Printf("=== Claude-Reactor Configuration ===\n\n")
        cmd.Printf("Project Configuration:\n")
        cmd.Printf("  Variant:     %s\n", getDisplayValue(config.Variant, "auto-detect"))
        cmd.Printf("  Account:     %s\n", getDisplayValue(config.Account, "default"))
        cmd.Printf("  Danger Mode: %t\n", config.DangerMode)
        cmd.Printf("  Project Path: %s\n", getDisplayValue(config.ProjectPath, getCurrentDir()))
        
        // Registry configuration (Phase 0.4)
        cmd.Printf("\nRegistry Configuration:\n")
        registryURL := os.Getenv("CLAUDE_REACTOR_REGISTRY")
        if registryURL == "" </span><span class="cov8" title="1">{
                registryURL = "ghcr.io/dyluth/claude-reactor (default)"
        }</span>
        <span class="cov8" title="1">cmd.Printf("  Registry URL: %s\n", registryURL)
        
        registryTag := os.Getenv("CLAUDE_REACTOR_TAG")
        if registryTag == "" </span><span class="cov8" title="1">{
                registryTag = "latest (default)"
        }</span>
        <span class="cov8" title="1">cmd.Printf("  Tag:          %s\n", registryTag)
        
        useRegistry := os.Getenv("CLAUDE_REACTOR_USE_REGISTRY")
        registryStatus := "enabled (default)"
        if useRegistry == "false" || useRegistry == "0" </span><span class="cov0" title="0">{
                registryStatus = "disabled"
        }</span>
        <span class="cov8" title="1">cmd.Printf("  Status:       %s\n", registryStatus)
        
        // System information
        if verbose </span><span class="cov0" title="0">{
                cmd.Printf("\nSystem Information:\n")
                
                // Architecture
                arch, err := app.ArchDetector.GetHostArchitecture()
                if err != nil </span><span class="cov0" title="0">{
                        arch = fmt.Sprintf("error: %v", err)
                }</span>
                <span class="cov0" title="0">cmd.Printf("  Architecture: %s\n", arch)
                
                platform, err := app.ArchDetector.GetDockerPlatform()
                if err != nil </span><span class="cov0" title="0">{
                        platform = fmt.Sprintf("error: %v", err)
                }</span>
                <span class="cov0" title="0">cmd.Printf("  Docker Platform: %s\n", platform)
                cmd.Printf("  Multi-arch Support: %t\n", app.ArchDetector.IsMultiArchSupported())
                
                // Container naming
                containerName := app.DockerMgr.GenerateContainerName("", config.Variant, arch, config.Account)
                cmd.Printf("  Container Name: %s\n", containerName)
                
                projectHash := app.DockerMgr.GenerateProjectHash("")
                cmd.Printf("  Project Hash: %s\n", projectHash)
                
                imageName := app.DockerMgr.GetImageName(config.Variant, arch)
                cmd.Printf("  Image Name: %s\n", imageName)
                
                // Authentication paths
                authPath := app.AuthMgr.GetAccountConfigPath(config.Account)
                cmd.Printf("  Auth Config Path: %s\n", authPath)
                
                apiKeyFile := app.AuthMgr.GetAPIKeyFile(config.Account)
                cmd.Printf("  API Key File: %s\n", apiKeyFile)</span>
        }
        
        // Raw configuration (Phase 0.4)
        <span class="cov8" title="1">if showRaw </span><span class="cov0" title="0">{
                cmd.Printf("\nRaw Configuration File:\n")
                configPath := ".claude-reactor" // Default config file name
                
                if data, err := os.ReadFile(configPath); err != nil </span><span class="cov0" title="0">{
                        cmd.Printf("  File: %s (not found or unreadable)\n", configPath)
                        cmd.Printf("  Status: Using default configuration\n")
                }</span> else<span class="cov0" title="0"> {
                        cmd.Printf("  File: %s\n", configPath)
                        cmd.Printf("  Contents:\n")
                        lines := strings.Split(string(data), "\n")
                        for _, line := range lines </span><span class="cov0" title="0">{
                                if strings.TrimSpace(line) != "" </span><span class="cov0" title="0">{
                                        cmd.Printf("    %s\n", line)
                                }</span>
                        }
                }
        }
        
        <span class="cov8" title="1">return nil</span>
}

// getDisplayValue returns the value or a default display string
func getDisplayValue(value, defaultDisplay string) string <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("(using %s)", defaultDisplay)
        }</span>
        <span class="cov8" title="1">return value</span>
}

// getCurrentDir safely gets the current directory
func getCurrentDir() string <span class="cov8" title="1">{
        if dir, err := os.Getwd(); err == nil </span><span class="cov8" title="1">{
                return dir
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// newDevContainerCmd creates the devcontainer command for VS Code integration
func newDevContainerCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var devcontainerCmd = &amp;cobra.Command{
                Use:   "devcontainer",
                Short: "VS Code Dev Container integration",
                Long:  `Generate and manage VS Code Dev Container configurations for seamless IDE integration.`,
        }
        
        // Generate subcommand
        generateCmd := &amp;cobra.Command{
                Use:   "generate [project-path]",
                Short: "Generate .devcontainer configuration",
                Long: `Generate VS Code Dev Container configuration based on project detection.
                
This command will:
- Detect your project type (Go, Rust, Node.js, Python, Java, etc.)
- Select the appropriate claude-reactor container variant
- Install relevant VS Code extensions automatically
- Configure proper mount points and settings
- Enable one-click "Reopen in Container" workflow`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return generateDevContainer(cmd, args, app)
                }</span>,
        }
        
        // Validate subcommand
        <span class="cov8" title="1">validateCmd := &amp;cobra.Command{
                Use:   "validate [project-path]",
                Short: "Validate existing .devcontainer configuration",
                Long:  "Check if existing .devcontainer configuration is valid and properly structured.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return validateDevContainer(cmd, args, app)
                }</span>,
        }
        
        // Update subcommand
        <span class="cov8" title="1">updateCmd := &amp;cobra.Command{
                Use:   "update [project-path]",
                Short: "Update existing .devcontainer configuration",
                Long:  "Update existing .devcontainer configuration with latest templates and settings.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return updateDevContainer(cmd, args, app)
                }</span>,
        }
        
        // Remove subcommand
        <span class="cov8" title="1">removeCmd := &amp;cobra.Command{
                Use:   "remove [project-path]",
                Short: "Remove .devcontainer configuration",
                Long:  "Remove .devcontainer directory and configurations from project.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return removeDevContainer(cmd, args, app)
                }</span>,
        }
        
        // Info subcommand
        <span class="cov8" title="1">infoCmd := &amp;cobra.Command{
                Use:   "info [project-path]",
                Short: "Show project detection information",
                Long:  "Display detailed project detection results and recommended VS Code extensions.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return showDevContainerInfo(cmd, args, app)
                }</span>,
        }
        
        // Add flags
        <span class="cov8" title="1">generateCmd.Flags().String("variant", "", "Force specific container variant (base, go, full, cloud, k8s)")
        generateCmd.Flags().Bool("force", false, "Overwrite existing .devcontainer configuration")
        
        // Help subcommand
        helpCmd := &amp;cobra.Command{
                Use:   "help",
                Short: "Detailed VS Code Dev Container setup guide",
                Long:  "Complete guide for setting up and using VS Code Dev Containers with claude-reactor.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return showVSCodeHelp(cmd, args, app)
                }</span>,
        }
        
        // Add subcommands
        <span class="cov8" title="1">devcontainerCmd.AddCommand(
                generateCmd,
                validateCmd,
                updateCmd,
                removeCmd,
                infoCmd,
                helpCmd,
        )
        
        return devcontainerCmd</span>
}

// generateDevContainer generates a new .devcontainer configuration
func generateDevContainer(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        projectPath := getCurrentDir()
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                projectPath = args[0]
        }</span>
        
        // Load current config
        <span class="cov0" title="0">config, err := app.ConfigMgr.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                config = app.ConfigMgr.GetDefaultConfig()
        }</span>
        <span class="cov0" title="0">config.ProjectPath = projectPath
        
        // Override variant if specified
        if variant, _ := cmd.Flags().GetString("variant"); variant != "" </span><span class="cov0" title="0">{
                if err := app.ConfigMgr.ValidateConfig(&amp;pkg.Config{Variant: variant}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid variant '%s': %w", variant, err)
                }</span>
                <span class="cov0" title="0">config.Variant = variant</span>
        }
        
        // Check if devcontainer already exists
        <span class="cov0" title="0">force, _ := cmd.Flags().GetBool("force")
        devcontainerPath := filepath.Join(projectPath, ".devcontainer")
        if _, err := os.Stat(devcontainerPath); err == nil &amp;&amp; !force </span><span class="cov0" title="0">{
                return fmt.Errorf(".devcontainer already exists at %s (use --force to overwrite)", devcontainerPath)
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("🔧 Generating VS Code Dev Container configuration...")
        
        // Generate devcontainer configuration
        if err := app.DevContainerMgr.GenerateDevContainer(projectPath, config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate devcontainer: %w", err)
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("✅ Successfully generated .devcontainer configuration!")
        app.Logger.Infof("")
        app.Logger.Infof("📋 VS Code Setup Instructions:")
        app.Logger.Infof("   1. Install 'Dev Containers' extension: ms-vscode-remote.remote-containers")
        app.Logger.Infof("   2. Open this project in VS Code: code .")
        app.Logger.Infof("   3. VS Code will show: 'Folder contains a Dev Container configuration file'")
        app.Logger.Infof("   4. Click 'Reopen in Container' or use Command Palette:")
        app.Logger.Infof("      • Press Ctrl/Cmd+Shift+P")
        app.Logger.Infof("      • Type: 'Dev Containers: Reopen in Container'")
        app.Logger.Infof("   5. Wait for container build and VS Code connection (~30-60 seconds)")
        app.Logger.Infof("   6. Extensions will auto-install - check bottom status bar")
        app.Logger.Infof("")
        app.Logger.Infof("🔧 Troubleshooting:")
        app.Logger.Infof("   • If 'Dockerfile does not exist': Ensure you opened VS Code from the project root directory")
        app.Logger.Infof("   • If build fails: Ensure Docker is running and try 'Rebuild Container'")
        app.Logger.Infof("   • If extensions missing: Check 'Extensions' view, they install automatically")
        app.Logger.Infof("   • To rebuild: Command Palette → 'Dev Containers: Rebuild Container'")
        app.Logger.Infof("   • To exit container: Command Palette → 'Dev Containers: Reopen Folder Locally'")
        app.Logger.Infof("   • Path issues: Run 'claude-reactor devcontainer validate' to check configuration")
        app.Logger.Infof("")
        app.Logger.Infof("🚀 You're all set for containerized development!")
        
        return nil</span>
}

// validateDevContainer validates existing .devcontainer configuration
func validateDevContainer(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        projectPath := getCurrentDir()
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                projectPath = args[0]
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("🔍 Validating .devcontainer configuration...")
        
        if err := app.DevContainerMgr.ValidateDevContainer(projectPath); err != nil </span><span class="cov0" title="0">{
                app.Logger.Errorf("❌ Validation failed: %v", err)
                return err
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("✅ DevContainer configuration is valid!")
        return nil</span>
}

// updateDevContainer updates existing .devcontainer configuration
func updateDevContainer(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        projectPath := getCurrentDir()
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                projectPath = args[0]
        }</span>
        
        // Load current config
        <span class="cov0" title="0">config, err := app.ConfigMgr.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                config = app.ConfigMgr.GetDefaultConfig()
        }</span>
        <span class="cov0" title="0">config.ProjectPath = projectPath
        
        app.Logger.Infof("🔄 Updating .devcontainer configuration...")
        
        if err := app.DevContainerMgr.UpdateDevContainer(projectPath, config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update devcontainer: %w", err)
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("✅ Successfully updated .devcontainer configuration!")
        return nil</span>
}

// removeDevContainer removes .devcontainer configuration
func removeDevContainer(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        projectPath := getCurrentDir()
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                projectPath = args[0]
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("🗑️  Removing .devcontainer configuration...")
        
        if err := app.DevContainerMgr.RemoveDevContainer(projectPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove devcontainer: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// showDevContainerInfo shows project detection information
func showDevContainerInfo(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        projectPath := getCurrentDir()
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                projectPath = args[0]
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("🔍 Analyzing project: %s", projectPath)
        
        // Perform project detection
        detection, err := app.DevContainerMgr.DetectProjectType(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect project type: %w", err)
        }</span>
        
        // Display results
        <span class="cov0" title="0">fmt.Printf("\n📊 Project Detection Results:\n")
        fmt.Printf("  Project Type: %s\n", detection.ProjectType)
        fmt.Printf("  Recommended Variant: %s\n", detection.Variant)
        fmt.Printf("  Confidence: %.1f%%\n", detection.Confidence*100)
        
        if len(detection.Languages) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Languages: %s\n", strings.Join(detection.Languages, ", "))
        }</span>
        
        <span class="cov0" title="0">if len(detection.Frameworks) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Frameworks: %s\n", strings.Join(detection.Frameworks, ", "))
        }</span>
        
        <span class="cov0" title="0">if len(detection.Features) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Features: %s\n", strings.Join(detection.Features, ", "))
        }</span>
        
        <span class="cov0" title="0">if len(detection.Files) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Detected Files: %s\n", strings.Join(detection.Files, ", "))
        }</span>
        
        <span class="cov0" title="0">if len(detection.Extensions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n📦 Recommended VS Code Extensions:\n")
                for i, ext := range detection.Extensions </span><span class="cov0" title="0">{
                        if i &lt; 10 </span><span class="cov0" title="0">{ // Show first 10 extensions
                                fmt.Printf("  - %s\n", ext)
                        }</span>
                }
                <span class="cov0" title="0">if len(detection.Extensions) &gt; 10 </span><span class="cov0" title="0">{
                        fmt.Printf("  ... and %d more extensions\n", len(detection.Extensions)-10)
                }</span>
        }
        
        <span class="cov0" title="0">fmt.Printf("\n💡 Run 'claude-reactor devcontainer generate' to create .devcontainer configuration\n")
        
        return nil</span>
}

// showVSCodeHelp displays comprehensive VS Code Dev Container setup guide
func showVSCodeHelp(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        helpText := `
🎯 VS Code Dev Container Integration Guide

═══════════════════════════════════════════════════════════════════════════════

📋 PREREQUISITES

1. Install Docker Desktop
   • macOS/Windows: https://www.docker.com/products/docker-desktop
   • Linux: Install Docker Engine + Docker Compose

2. Install VS Code
   • Download: https://code.visualstudio.com/

3. Install Dev Containers Extension
   • Open VS Code
   • Go to Extensions (Ctrl/Cmd+Shift+X)
   • Search: "Dev Containers" 
   • Install: ms-vscode-remote.remote-containers
   • Or install via command line: code --install-extension ms-vscode-remote.remote-containers

═══════════════════════════════════════════════════════════════════════════════

🚀 QUICK START

1. Generate devcontainer for your project:
   claude-reactor devcontainer generate

2. Open project in VS Code:
   code .

3. When prompted, click "Reopen in Container"
   • Or use Command Palette: Ctrl/Cmd+Shift+P → "Dev Containers: Reopen in Container"

4. Wait for container build (30-60 seconds first time)

5. Start coding with full IDE integration! 🎉

═══════════════════════════════════════════════════════════════════════════════

🔧 DETAILED WORKFLOW

Step 1: Project Analysis
   • Run: claude-reactor devcontainer info
   • Review detected project type, variant, and recommended extensions
   
Step 2: Generate Configuration  
   • Run: claude-reactor devcontainer generate
   • Creates .devcontainer/devcontainer.json with optimal settings
   • Force overwrite existing: claude-reactor devcontainer generate --force
   • Specify variant: claude-reactor devcontainer generate --variant go

Step 3: Open in VS Code
   • Launch VS Code in project directory: code .
   • VS Code detects .devcontainer/devcontainer.json automatically
   • Shows notification: "Folder contains a Dev Container configuration file"

Step 4: Container Setup
   • Click "Reopen in Container" in notification
   • Alternative: Command Palette (Ctrl/Cmd+Shift+P) → "Dev Containers: Reopen in Container"
   • VS Code builds Docker container (uses claude-reactor Dockerfile)
   • Connects to container and installs extensions
   • Terminal opens inside container environment

Step 5: Development
   • All tools available: go, rust, python, node, docker, kubectl, etc.
   • Extensions auto-installed and configured
   • IntelliSense, debugging, and Git work seamlessly
   • Files sync between host and container automatically

═══════════════════════════════════════════════════════════════════════════════

⚙️ CONTAINER VARIANTS &amp; PROJECT TYPES

Base Variant (Python, Node.js):
   • Languages: Python 3.11, Node.js 18, pip, npm, uv
   • Extensions: Python, TypeScript, ESLint, Prettier
   • Use case: Web apps, APIs, scripts

Go Variant (Go projects):
   • Languages: Go 1.23, all Go tools (gofmt, golint, etc.)
   • Extensions: Go, go-nightly, vscode-go
   • Use case: Go applications, CLIs, microservices

Full Variant (Rust, Java):
   • Languages: Rust, Java 17, Maven, Gradle
   • Extensions: rust-analyzer, Java extension pack
   • Use case: System programming, enterprise apps

Cloud Variant (Cloud development):
   • All Full variant tools + AWS CLI, gcloud, Azure CLI
   • Extensions: AWS Toolkit, Cloud Code, Docker
   • Use case: Cloud-native applications, DevOps

K8s Variant (Kubernetes development):
   • All Full variant tools + kubectl, helm, k9s, stern
   • Extensions: Kubernetes Tools, Helm IntelliSense
   • Use case: Kubernetes operators, microservices, DevOps

═══════════════════════════════════════════════════════════════════════════════

🔍 TROUBLESHOOTING

Problem: "Reopen in Container" notification doesn't appear
Solution: 
   • Ensure .devcontainer/devcontainer.json exists
   • Reload VS Code: Ctrl/Cmd+Shift+P → "Developer: Reload Window"
   • Manually trigger: Command Palette → "Dev Containers: Reopen in Container"

Problem: Container build fails
Solutions:
   • Ensure Docker is running: docker ps
   • Check Docker resources (memory &gt; 4GB recommended)
   • Rebuild: Command Palette → "Dev Containers: Rebuild Container"
   • View build logs: Command Palette → "Dev Containers: Show Container Log"

Problem: Extensions not installing
Solutions:
   • Check Extensions view - they install automatically
   • Restart VS Code if needed
   • Manually install missing extensions inside container
   • Check internet connection for extension downloads

Problem: Slow performance
Solutions:
   • Increase Docker memory allocation (Docker Desktop settings)
   • Use volume mounts instead of bind mounts for large projects
   • Close unnecessary extensions
   • Check host system resources

Problem: File sync issues
Solutions:
   • Files should sync automatically with bind mounts
   • If not syncing, restart container: Command Palette → "Dev Containers: Rebuild Container"
   • Check file permissions and Docker volume settings

Problem: Git integration not working
Solutions:
   • VS Code mounts ~/.gitconfig automatically
   • For SSH keys, ensure ssh-agent is running on host
   • Configure Git inside container if needed: git config --global user.name "Your Name"

═══════════════════════════════════════════════════════════════════════════════

💡 PRO TIPS

1. Keyboard Shortcuts:
   • Open Command Palette: Ctrl/Cmd+Shift+P
   • Open terminal: Ctrl/Cmd+backtick
   • Switch between local/container: Command Palette → "Dev Containers: Reopen Folder Locally"

2. Multiple Projects:
   • Each project gets its own devcontainer configuration
   • VS Code remembers container settings per project
   • Switch between projects seamlessly

3. Team Collaboration:
   • Commit .devcontainer/ to version control
   • All team members get identical development environment
   • No more "works on my machine" issues

4. Performance Optimization:
   • First container build is slow (~2-3 minutes)
   • Subsequent builds are fast (~30 seconds) due to Docker layer caching
   • Keep Docker running to avoid startup delays

5. Custom Extensions:
   • Edit .devcontainer/devcontainer.json to add custom extensions
   • Run: claude-reactor devcontainer update to refresh configuration

═══════════════════════════════════════════════════════════════════════════════

📚 USEFUL COMMANDS

claude-reactor devcontainer info              # Analyze current project
claude-reactor devcontainer generate          # Create .devcontainer config  
claude-reactor devcontainer generate --force  # Overwrite existing config
claude-reactor devcontainer validate          # Check config validity
claude-reactor devcontainer update            # Update existing config
claude-reactor devcontainer remove            # Delete .devcontainer directory

VS Code Command Palette (Ctrl/Cmd+Shift+P):
   • Dev Containers: Reopen in Container
   • Dev Containers: Reopen Folder Locally  
   • Dev Containers: Rebuild Container
   • Dev Containers: Show Container Log
   • Dev Containers: Attach to Running Container

═══════════════════════════════════════════════════════════════════════════════

🎯 SUCCESS INDICATORS

✅ Container Built Successfully:
   • VS Code status bar shows: "Dev Container: Claude Reactor [Variant]"
   • Terminal prompt shows container environment
   • Extensions appear in Extensions view

✅ Tools Working:
   • IntelliSense provides code completion
   • Go to Definition works (F12)
   • Debugging available (F5)
   • Integrated terminal has all development tools

✅ Full Integration:
   • Git operations work seamlessly
   • File changes sync between host and container
   • Port forwarding works for web applications
   • Extensions provide full functionality

Happy containerized coding! 🚀

Run 'claude-reactor devcontainer help' anytime to see this guide.

`
        
        fmt.Print(helpText)
        return nil
}</span>

// newTemplateCmd creates the template command for project scaffolding
func newTemplateCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var templateCmd = &amp;cobra.Command{
                Use:   "template",
                Short: "Project template management and scaffolding",
                Long: `The template command provides intelligent project scaffolding and template management.
                
Create new projects from templates, manage custom templates, and scaffold projects
with best practices and proper configuration for claude-reactor development.`,
                Example: `# List available templates
claude-reactor template list

# Create new project from template
claude-reactor template new go-api my-api

# Interactive project creation
claude-reactor template init

# Show template details
claude-reactor template show go-api`,
        }

        templateCmd.AddCommand(
                newTemplateListCmd(app),
                newTemplateShowCmd(app),
                newTemplateNewCmd(app),
                newTemplateInitCmd(app),
                newTemplateCreateCmd(app),
                newTemplateInstallCmd(app),
                newTemplateUninstallCmd(app),
                newTemplateValidateCmd(app),
        )

        return templateCmd
}</span>

// newTemplateListCmd lists available templates
func newTemplateListCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var listCmd = &amp;cobra.Command{
                Use:   "list [language]",
                Short: "List available project templates",
                Long: `Lists all available project templates or filters by language.
                
Templates are organized by language and framework, each providing a complete
project structure with best practices and proper claude-reactor integration.`,
                Example: `# List all templates
claude-reactor template list

# List Go templates only  
claude-reactor template list go

# List with details
claude-reactor template list --detailed`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return listTemplates(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">listCmd.Flags().BoolP("detailed", "d", false, "Show detailed template information")
        return listCmd</span>
}

// newTemplateShowCmd shows template details
func newTemplateShowCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var showCmd = &amp;cobra.Command{
                Use:   "show &lt;template-name&gt;",
                Short: "Show detailed information about a template",
                Long: `Displays comprehensive information about a specific template including:
- Description and metadata
- Files that will be created
- Template variables
- Post-creation commands
- Requirements and dependencies`,
                Example: `# Show Go API template details
claude-reactor template show go-api

# Show with file contents
claude-reactor template show go-api --files`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return showTemplate(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">showCmd.Flags().Bool("files", false, "Show file contents preview")
        return showCmd</span>
}

// newTemplateNewCmd creates new project from template
func newTemplateNewCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var newCmd = &amp;cobra.Command{
                Use:   "new &lt;template-name&gt; &lt;project-name&gt; [path]",
                Short: "Create new project from template",
                Long: `Creates a new project from the specified template with intelligent scaffolding.
                
The command will:
1. Create project directory structure
2. Generate files with template variables
3. Set up .claude-reactor configuration
4. Initialize git repository (optional)
5. Generate devcontainer configuration (optional)
6. Run post-creation commands`,
                Example: `# Create Go API project
claude-reactor template new go-api my-api

# Create in specific directory
claude-reactor template new go-api my-api ./projects/

# Skip git initialization
claude-reactor template new go-api my-api --no-git

# Set template variables
claude-reactor template new go-api my-api --var PORT=3000 --var AUTHOR="John Doe"`,
                Args: cobra.RangeArgs(2, 3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return createFromTemplate(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">newCmd.Flags().Bool("no-git", false, "Skip git repository initialization")
        newCmd.Flags().Bool("no-devcontainer", false, "Skip devcontainer generation")
        newCmd.Flags().StringSlice("var", []string{}, "Set template variables (key=value)")
        newCmd.Flags().Bool("force", false, "Overwrite existing directory")
        return newCmd</span>
}

// newTemplateInitCmd runs interactive project creation
func newTemplateInitCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var initCmd = &amp;cobra.Command{
                Use:   "init [path]",
                Short: "Interactive project initialization wizard",
                Long: `Runs an interactive wizard to create a new project.
                
The wizard will:
1. Show available templates
2. Help you select the best template
3. Collect project information
4. Set template variables
5. Create the project with all configurations`,
                Example: `# Start interactive wizard in current directory
claude-reactor template init

# Start wizard in specific directory
claude-reactor template init ./projects/`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return interactiveInit(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">return initCmd</span>
}

// newTemplateCreateCmd creates template from existing project
func newTemplateCreateCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var createCmd = &amp;cobra.Command{
                Use:   "create &lt;template-name&gt; [project-path]",
                Short: "Create template from existing project",
                Long: `Creates a new template based on an existing project structure.
                
This is useful for:
- Creating custom templates from your projects
- Sharing project structures with team members
- Building organization-specific templates`,
                Example: `# Create template from current directory
claude-reactor template create my-template

# Create template from specific project
claude-reactor template create my-template ./my-project/

# Include custom metadata
claude-reactor template create my-template --description "My custom template" --author "John Doe"`,
                Args: cobra.RangeArgs(1, 2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return createTemplate(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">createCmd.Flags().String("description", "", "Template description")
        createCmd.Flags().String("author", "", "Template author")
        createCmd.Flags().StringSlice("tags", []string{}, "Template tags")
        return createCmd</span>
}

// newTemplateInstallCmd installs template from file or URL
func newTemplateInstallCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var installCmd = &amp;cobra.Command{
                Use:   "install &lt;source&gt;",
                Short: "Install template from file or URL",
                Long: `Installs a template from a local file or remote URL.
                
Supported sources:
- Local YAML files (template.yaml)
- Git repositories (future)
- Template registries (future)`,
                Example: `# Install from local file
claude-reactor template install ./my-template.yaml

# Install from URL (future)
claude-reactor template install https://example.com/template.yaml`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return installTemplate(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">return installCmd</span>
}

// newTemplateUninstallCmd removes a template
func newTemplateUninstallCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var uninstallCmd = &amp;cobra.Command{
                Use:   "uninstall &lt;template-name&gt;",
                Short: "Remove an installed template",
                Long: `Removes a template from the local template registry.
                
This will permanently delete the template configuration and files.
Built-in templates cannot be uninstalled.`,
                Example: `# Remove custom template
claude-reactor template uninstall my-custom-template

# Force removal without confirmation
claude-reactor template uninstall my-template --force`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return uninstallTemplate(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">uninstallCmd.Flags().Bool("force", false, "Force removal without confirmation")
        return uninstallCmd</span>
}

// newTemplateValidateCmd validates a template
func newTemplateValidateCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var validateCmd = &amp;cobra.Command{
                Use:   "validate &lt;template-file&gt;",
                Short: "Validate template configuration",
                Long: `Validates a template configuration file for correctness.
                
Checks:
- YAML syntax
- Required fields
- File references
- Variable definitions
- Template syntax`,
                Example: `# Validate local template file
claude-reactor template validate ./template.yaml

# Validate installed template
claude-reactor template validate go-api`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return validateTemplate(cmd, args, app)
                }</span>,
        }

        <span class="cov8" title="1">return validateCmd</span>
}

// listTemplates lists available project templates
func listTemplates(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        detailed, _ := cmd.Flags().GetBool("detailed")
        
        var templates []*pkg.ProjectTemplate
        var err error
        
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                // Filter by language
                language := args[0]
                templates, err = app.TemplateMgr.GetTemplatesForLanguage(language)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get templates for language %s: %w", language, err)
                }</span>
                <span class="cov0" title="0">app.Logger.Infof("📋 Available %s templates:", strings.Title(language))</span>
        } else<span class="cov0" title="0"> {
                // Get all templates
                templates, err = app.TemplateMgr.ListTemplates()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list templates: %w", err)
                }</span>
                <span class="cov0" title="0">app.Logger.Infof("📋 Available project templates:")</span>
        }
        
        <span class="cov0" title="0">if len(templates) == 0 </span><span class="cov0" title="0">{
                fmt.Println("\n❌ No templates found")
                fmt.Println("💡 Templates will be automatically created on first use")
                return nil
        }</span>
        
        <span class="cov0" title="0">if detailed </span><span class="cov0" title="0">{
                for _, template := range templates </span><span class="cov0" title="0">{
                        fmt.Printf("\n🎯 %s (%s)\n", template.Name, template.Language)
                        fmt.Printf("   Description: %s\n", template.Description)
                        fmt.Printf("   Framework: %s\n", template.Framework)
                        fmt.Printf("   Variant: %s\n", template.Variant)
                        fmt.Printf("   Version: %s\n", template.Version)
                        if len(template.Tags) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Tags: %s\n", strings.Join(template.Tags, ", "))
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   Files: %d\n", len(template.Files))
                        if len(template.Variables) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Variables: %d\n", len(template.Variables))
                        }</span>
                        <span class="cov0" title="0">if template.DevContainer </span><span class="cov0" title="0">{
                                fmt.Printf("   ✅ Includes VS Code Dev Container\n")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Group by language
                languageGroups := make(map[string][]*pkg.ProjectTemplate)
                for _, template := range templates </span><span class="cov0" title="0">{
                        languageGroups[template.Language] = append(languageGroups[template.Language], template)
                }</span>
                
                <span class="cov0" title="0">for language, langTemplates := range languageGroups </span><span class="cov0" title="0">{
                        fmt.Printf("\n📁 %s:\n", strings.Title(language))
                        for _, template := range langTemplates </span><span class="cov0" title="0">{
                                framework := ""
                                if template.Framework != "" </span><span class="cov0" title="0">{
                                        framework = fmt.Sprintf(" (%s)", template.Framework)
                                }</span>
                                <span class="cov0" title="0">devcontainer := ""
                                if template.DevContainer </span><span class="cov0" title="0">{
                                        devcontainer = " 📦"
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("  • %s%s - %s%s\n", template.Name, framework, template.Description, devcontainer)</span>
                        }
                }
                
                <span class="cov0" title="0">fmt.Printf("\n💡 Use 'claude-reactor template show &lt;template-name&gt;' for details\n")
                fmt.Printf("💡 Use 'claude-reactor template new &lt;template-name&gt; &lt;project-name&gt;' to create project\n")</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// showTemplate shows detailed information about a template
func showTemplate(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        templateName := args[0]
        showFiles, _ := cmd.Flags().GetBool("files")
        
        template, err := app.TemplateMgr.GetTemplate(templateName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get template: %w", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("🎯 Template: %s\n", template.Name)
        fmt.Printf("📝 Description: %s\n", template.Description)
        fmt.Printf("🔧 Language: %s\n", template.Language)
        if template.Framework != "" </span><span class="cov0" title="0">{
                fmt.Printf("🏗️  Framework: %s\n", template.Framework)
        }</span>
        <span class="cov0" title="0">fmt.Printf("📦 Variant: %s\n", template.Variant)
        fmt.Printf("🏷️  Version: %s\n", template.Version)
        if template.Author != "" </span><span class="cov0" title="0">{
                fmt.Printf("👤 Author: %s\n", template.Author)
        }</span>
        <span class="cov0" title="0">if len(template.Tags) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("🏷️  Tags: %s\n", strings.Join(template.Tags, ", "))
        }</span>
        
        <span class="cov0" title="0">if template.DevContainer </span><span class="cov0" title="0">{
                fmt.Printf("✅ Includes VS Code Dev Container integration\n")
        }</span>
        
        <span class="cov0" title="0">if len(template.Variables) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n📋 Template Variables:\n")
                for _, variable := range template.Variables </span><span class="cov0" title="0">{
                        defaultStr := ""
                        if variable.Default != nil </span><span class="cov0" title="0">{
                                defaultStr = fmt.Sprintf(" (default: %v)", variable.Default)
                        }</span>
                        <span class="cov0" title="0">requiredStr := ""
                        if variable.Required </span><span class="cov0" title="0">{
                                requiredStr = " *required*"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  • %s (%s): %s%s%s\n", variable.Name, variable.Type, variable.Description, defaultStr, requiredStr)
                        if variable.Type == "choice" &amp;&amp; len(variable.Choices) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("    Choices: %s\n", strings.Join(variable.Choices, ", "))
                        }</span>
                }
        }
        
        <span class="cov0" title="0">fmt.Printf("\n📁 Files (%d):\n", len(template.Files))
        for _, file := range template.Files </span><span class="cov0" title="0">{
                templateStr := ""
                if file.Template </span><span class="cov0" title="0">{
                        templateStr = " [templated]"
                }</span>
                <span class="cov0" title="0">execStr := ""
                if file.Executable </span><span class="cov0" title="0">{
                        execStr = " [executable]"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  • %s%s%s\n", file.Path, templateStr, execStr)
                
                if showFiles &amp;&amp; file.Content != "" </span><span class="cov0" title="0">{
                        lines := strings.Split(file.Content, "\n")
                        preview := lines
                        if len(lines) &gt; 10 </span><span class="cov0" title="0">{
                                preview = lines[:10]
                                fmt.Printf("    Preview (first 10 lines):\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("    Content:\n")
                        }</span>
                        <span class="cov0" title="0">for _, line := range preview </span><span class="cov0" title="0">{
                                fmt.Printf("      %s\n", line)
                        }</span>
                        <span class="cov0" title="0">if len(lines) &gt; 10 </span><span class="cov0" title="0">{
                                fmt.Printf("    ... (%d more lines)\n", len(lines)-10)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }
        
        <span class="cov0" title="0">if len(template.GitIgnore) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n🚫 Git Ignore Patterns (%d):\n", len(template.GitIgnore))
                for _, pattern := range template.GitIgnore </span><span class="cov0" title="0">{
                        if pattern != "" </span><span class="cov0" title="0">{
                                fmt.Printf("  • %s\n", pattern)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if len(template.PostCreate) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n⚡ Post-Creation Commands:\n")
                for _, cmd := range template.PostCreate </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", cmd)
                }</span>
        }
        
        <span class="cov0" title="0">if len(template.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n📦 Dependencies:\n")
                for _, dep := range template.Dependencies </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", dep)
                }</span>
        }
        
        <span class="cov0" title="0">fmt.Printf("\n💡 Create project: claude-reactor template new %s &lt;project-name&gt;\n", template.Name)
        
        return nil</span>
}

// createFromTemplate creates a new project from template
func createFromTemplate(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        templateName := args[0]
        projectName := args[1]
        
        projectPath := "."
        if len(args) &gt; 2 </span><span class="cov0" title="0">{
                projectPath = args[2]
        }</span>
        
        // Get flags
        <span class="cov0" title="0">force, _ := cmd.Flags().GetBool("force")
        noGit, _ := cmd.Flags().GetBool("no-git")
        noDevcontainer, _ := cmd.Flags().GetBool("no-devcontainer")
        vars, _ := cmd.Flags().GetStringSlice("var")
        
        // Parse template variables
        variables := make(map[string]string)
        for _, v := range vars </span><span class="cov0" title="0">{
                parts := strings.SplitN(v, "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        variables[parts[0]] = parts[1]
                }</span> else<span class="cov0" title="0"> {
                        app.Logger.Warnf("Invalid variable format: %s (expected key=value)", v)
                }</span>
        }
        
        // Build full project path
        <span class="cov0" title="0">fullProjectPath := filepath.Join(projectPath, projectName)
        
        // Check if directory exists
        if _, err := os.Stat(fullProjectPath); err == nil &amp;&amp; !force </span><span class="cov0" title="0">{
                return fmt.Errorf("directory %s already exists (use --force to overwrite)", fullProjectPath)
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("🏗️ Creating project '%s' from template '%s'", projectName, templateName)
        
        // Create project from template
        result, err := app.TemplateMgr.ScaffoldProject(templateName, fullProjectPath, projectName, variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scaffold project: %w", err)
        }</span>
        
        // Display results
        <span class="cov0" title="0">fmt.Printf("\n✅ Project '%s' created successfully!\n", projectName)
        fmt.Printf("📁 Location: %s\n", result.ProjectPath)
        fmt.Printf("🎯 Template: %s (%s)\n", result.TemplateName, result.Language)
        fmt.Printf("📦 Variant: %s\n", result.Variant)
        fmt.Printf("📄 Files Created: %d\n", len(result.FilesCreated))
        
        if result.DevContainerGen &amp;&amp; !noDevcontainer </span><span class="cov0" title="0">{
                fmt.Printf("✅ VS Code Dev Container configured\n")
        }</span>
        
        <span class="cov0" title="0">if result.GitInitialized &amp;&amp; !noGit </span><span class="cov0" title="0">{
                fmt.Printf("✅ Git repository initialized\n")
        }</span>
        
        <span class="cov0" title="0">if result.PostCreateRan </span><span class="cov0" title="0">{
                fmt.Printf("✅ Post-creation commands executed\n")
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("\n🚀 Next Steps:\n")
        fmt.Printf("  1. cd %s\n", projectName)
        if result.Language == "go" || result.Language == "rust" || result.Language == "node" </span><span class="cov0" title="0">{
                fmt.Printf("  2. Install dependencies (see README.md)\n")
        }</span>
        <span class="cov0" title="0">if result.DevContainerGen </span><span class="cov0" title="0">{
                fmt.Printf("  3. Open in VS Code: code .\n")
                fmt.Printf("  4. Reopen in Dev Container when prompted\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  3. Start development with: claude-reactor run\n")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// interactiveInit runs the interactive project creation wizard
func interactiveInit(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        projectPath := "."
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                projectPath = args[0]
        }</span>
        
        <span class="cov0" title="0">app.Logger.Infof("🧙 Starting interactive project creation wizard...")
        
        result, err := app.TemplateMgr.InteractiveScaffold(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("interactive scaffolding failed: %w", err)
        }</span>
        
        // Display results (same as createFromTemplate)
        <span class="cov0" title="0">fmt.Printf("\n✅ Project '%s' created successfully!\n", result.ProjectName)
        fmt.Printf("📁 Location: %s\n", result.ProjectPath)
        fmt.Printf("🎯 Template: %s (%s)\n", result.TemplateName, result.Language)
        fmt.Printf("📦 Variant: %s\n", result.Variant)
        fmt.Printf("📄 Files Created: %d\n", len(result.FilesCreated))
        
        fmt.Printf("\n🚀 Next Steps:\n")
        fmt.Printf("  1. cd %s\n", result.ProjectName)
        if result.DevContainerGen </span><span class="cov0" title="0">{
                fmt.Printf("  2. Open in VS Code: code .\n")
                fmt.Printf("  3. Reopen in Dev Container when prompted\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  2. Start development with: claude-reactor run\n")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// createTemplate creates a template from existing project
func createTemplate(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        templateName := args[0]
        projectPath := "."
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                projectPath = args[1]
        }</span>
        
        <span class="cov0" title="0">description, _ := cmd.Flags().GetString("description")
        author, _ := cmd.Flags().GetString("author")
        tags, _ := cmd.Flags().GetStringSlice("tags")
        
        app.Logger.Infof("🏗️ Creating template '%s' from project at %s", templateName, projectPath)
        
        template, err := app.TemplateMgr.CreateTemplate(projectPath, templateName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create template: %w", err)
        }</span>
        
        // Update template metadata if provided
        <span class="cov0" title="0">if description != "" </span><span class="cov0" title="0">{
                template.Description = description
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                template.Author = author
        }</span>
        <span class="cov0" title="0">if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                template.Tags = append(template.Tags, tags...)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("\n✅ Template '%s' created successfully!\n", template.Name)
        fmt.Printf("📝 Description: %s\n", template.Description)
        fmt.Printf("🔧 Language: %s\n", template.Language)
        fmt.Printf("📦 Variant: %s\n", template.Variant)
        fmt.Printf("📄 Files: %d\n", len(template.Files))
        
        fmt.Printf("\n💡 Use template: claude-reactor template new %s &lt;project-name&gt;\n", template.Name)
        
        return nil</span>
}

// installTemplate installs a template from file or URL
func installTemplate(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        source := args[0]
        
        app.Logger.Infof("📦 Installing template from %s", source)
        
        if err := app.TemplateMgr.InstallTemplate(source); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install template: %w", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("✅ Template installed successfully!\n")
        fmt.Printf("💡 Use 'claude-reactor template list' to see all available templates\n")
        
        return nil</span>
}

// uninstallTemplate removes a template
func uninstallTemplate(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        templateName := args[0]
        force, _ := cmd.Flags().GetBool("force")
        
        if !force </span><span class="cov0" title="0">{
                // Check if template exists
                _, err := app.TemplateMgr.GetTemplate(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template '%s' not found", templateName)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("⚠️  This will permanently remove template '%s'\n", templateName)
                fmt.Print("Are you sure? (y/N): ")
                
                var response string
                fmt.Scanln(&amp;response)
                if strings.ToLower(response) != "y" &amp;&amp; strings.ToLower(response) != "yes" </span><span class="cov0" title="0">{
                        fmt.Println("❌ Cancelled")
                        return nil
                }</span>
        }
        
        <span class="cov0" title="0">app.Logger.Infof("🗑️ Removing template '%s'", templateName)
        
        if err := app.TemplateMgr.UninstallTemplate(templateName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to uninstall template: %w", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("✅ Template '%s' removed successfully!\n", templateName)
        
        return nil</span>
}

// validateTemplate validates a template configuration
func validateTemplate(cmd *cobra.Command, args []string, app *pkg.AppContainer) error <span class="cov0" title="0">{
        templateSource := args[0]
        
        app.Logger.Infof("🔍 Validating template: %s", templateSource)
        
        // Check if it's a template name or file path
        var template *pkg.ProjectTemplate
        var err error
        
        if strings.HasSuffix(templateSource, ".yaml") || strings.HasSuffix(templateSource, ".yml") </span><span class="cov0" title="0">{
                // Validate file directly
                fmt.Printf("⚠️  Direct file validation not yet implemented\n")
                fmt.Printf("💡 Use: claude-reactor template install %s &amp;&amp; claude-reactor template validate &lt;template-name&gt;\n", templateSource)
                return nil
        }</span> else<span class="cov0" title="0"> {
                // Get installed template
                template, err = app.TemplateMgr.GetTemplate(templateSource)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get template: %w", err)
                }</span>
        }
        
        // Validate template
        <span class="cov0" title="0">if err := app.TemplateMgr.ValidateTemplate(template); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Template validation failed:\n")
                fmt.Printf("   %v\n", err)
                return nil
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("✅ Template '%s' is valid!\n", template.Name)
        fmt.Printf("📝 Description: %s\n", template.Description)
        fmt.Printf("🔧 Language: %s\n", template.Language)
        fmt.Printf("📦 Variant: %s\n", template.Variant)
        fmt.Printf("📄 Files: %d\n", len(template.Files))
        if len(template.Variables) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("🔧 Variables: %d\n", len(template.Variables))
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// newDependencyCmd creates the dependency management command tree
func newDependencyCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var dependencyCmd = &amp;cobra.Command{
                Use:   "dependency",
                Short: "Dependency management and package manager operations",
                Long: `Manage dependencies across all supported package managers.

Supports unified operations for:
• Go Modules (go.mod, go.sum)  
• Cargo (Cargo.toml, Cargo.lock)
• npm (package.json, package-lock.json)
• Yarn (package.json, yarn.lock)
• pnpm (package.json, pnpm-lock.yaml)
• pip (requirements.txt, setup.py, pyproject.toml)
• Poetry (pyproject.toml, poetry.lock)
• Pipenv (Pipfile, Pipfile.lock)
• Maven (pom.xml)
• Gradle (build.gradle, build.gradle.kts)

Examples:
  claude-reactor dependency detect     # Detect package managers in project
  claude-reactor dependency list      # List all dependencies
  claude-reactor dependency install   # Install dependencies for all package managers
  claude-reactor dependency update    # Update dependencies to latest versions
  claude-reactor dependency audit     # Scan for security vulnerabilities
  claude-reactor dependency outdated  # Check for outdated dependencies
  claude-reactor dependency report    # Generate comprehensive dependency report`,
                Aliases: []string{"deps", "dep"},
        }

        // Add subcommands
        dependencyCmd.AddCommand(
                newDependencyDetectCmd(app),
                newDependencyListCmd(app),
                newDependencyInstallCmd(app),
                newDependencyUpdateCmd(app),
                newDependencyAuditCmd(app),
                newDependencyOutdatedCmd(app),
                newDependencyReportCmd(app),
                newDependencyCleanCmd(app),
        )

        return dependencyCmd
}</span>

// newDependencyDetectCmd detects package managers in the current project
func newDependencyDetectCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "detect [path]",
                Short: "Detect package managers in project",
                Long: `Detect package managers and their configuration files in the current or specified project directory.

Shows available package managers on the system and detected package managers in the project.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">abs, err := filepath.Abs(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve project path: %w", err)
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("🔍 Detecting package managers in: %s", abs)
                        fmt.Printf("📦 Detecting package managers in: %s\n\n", abs)

                        // Detect project package managers
                        packageManagers, dependencies, err := app.DependencyMgr.DetectProjectDependencies(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to detect dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(packageManagers) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("❌ No package managers detected in project\n\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("✅ Found %d package manager(s):\n", len(packageManagers))
                                for _, pm := range packageManagers </span><span class="cov0" title="0">{
                                        status := "❌ not available"
                                        if pm.Available </span><span class="cov0" title="0">{
                                                status = "✅ available"
                                        }</span>
                                        
                                        <span class="cov0" title="0">version := ""
                                        if pm.Version != "" </span><span class="cov0" title="0">{
                                                version = fmt.Sprintf(" (v%s)", pm.Version)
                                        }</span>
                                        
                                        <span class="cov0" title="0">fmt.Printf("  • %s%s - %s\n", pm.Name, version, status)
                                        if len(pm.ConfigFiles) &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("    Config files: %s\n", strings.Join(pm.ConfigFiles, ", "))
                                        }</span>
                                        <span class="cov0" title="0">if len(pm.LockFiles) &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("    Lock files: %s\n", strings.Join(pm.LockFiles, ", "))
                                        }</span>
                                }
                                <span class="cov0" title="0">fmt.Printf("\n📊 Total dependencies detected: %d\n", len(dependencies))</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }
}

// newDependencyListCmd lists all dependencies in the project
func newDependencyListCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var showDetails bool
        var packageManager string
        
        cmd := &amp;cobra.Command{
                Use:   "list [path]",
                Short: "List all project dependencies",
                Long: `List dependencies from all detected package managers in the project.

Shows dependency name, version, type (direct/indirect), and package manager.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("📋 Listing dependencies in: %s", projectPath)

                        packageManagers, dependencies, err := app.DependencyMgr.DetectProjectDependencies(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to detect dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(packageManagers) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("❌ No package managers detected\n")
                                return nil
                        }</span>

                        // Filter by package manager if specified
                        <span class="cov0" title="0">if packageManager != "" </span><span class="cov0" title="0">{
                                var filtered []*pkg.DependencyInfo
                                for _, dep := range dependencies </span><span class="cov0" title="0">{
                                        if dep.PackageManager == packageManager </span><span class="cov0" title="0">{
                                                filtered = append(filtered, dep)
                                        }</span>
                                }
                                <span class="cov0" title="0">dependencies = filtered</span>
                        }

                        <span class="cov0" title="0">if len(dependencies) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("❌ No dependencies found\n")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("📋 Found %d dependencies across %d package managers:\n\n", len(dependencies), len(packageManagers))

                        // Group by package manager
                        depsByPM := make(map[string][]*pkg.DependencyInfo)
                        for _, dep := range dependencies </span><span class="cov0" title="0">{
                                depsByPM[dep.PackageManager] = append(depsByPM[dep.PackageManager], dep)
                        }</span>

                        <span class="cov0" title="0">for pmType, deps := range depsByPM </span><span class="cov0" title="0">{
                                if len(deps) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                
                                <span class="cov0" title="0">fmt.Printf("🔧 %s (%d dependencies):\n", strings.ToUpper(pmType), len(deps))
                                for _, dep := range deps </span><span class="cov0" title="0">{
                                        typeIcon := "📦"
                                        if dep.Type == "dev" </span><span class="cov0" title="0">{
                                                typeIcon = "🛠️"
                                        }</span> else<span class="cov0" title="0"> if dep.Type == "indirect" </span><span class="cov0" title="0">{
                                                typeIcon = "🔗"
                                        }</span>
                                        
                                        <span class="cov0" title="0">fmt.Printf("  %s %s@%s", typeIcon, dep.Name, dep.CurrentVersion)
                                        
                                        if showDetails </span><span class="cov0" title="0">{
                                                if dep.Description != "" </span><span class="cov0" title="0">{
                                                        fmt.Printf(" - %s", dep.Description)
                                                }</span>
                                                <span class="cov0" title="0">if dep.License != "" </span><span class="cov0" title="0">{
                                                        fmt.Printf(" [%s]", dep.License)
                                                }</span>
                                                <span class="cov0" title="0">if dep.IsOutdated </span><span class="cov0" title="0">{
                                                        fmt.Printf(" (outdated)")
                                                }</span>
                                                <span class="cov0" title="0">if dep.HasVulnerability </span><span class="cov0" title="0">{
                                                        fmt.Printf(" ⚠️ vulnerable")
                                                }</span>
                                        }
                                        <span class="cov0" title="0">fmt.Printf("\n")</span>
                                }
                                <span class="cov0" title="0">fmt.Printf("\n")</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;showDetails, "details", "d", false, "Show detailed dependency information")
        cmd.Flags().StringVarP(&amp;packageManager, "manager", "m", "", "Filter by package manager (go, npm, cargo, etc.)")

        return cmd</span>
}

// newDependencyInstallCmd installs dependencies for all package managers
func newDependencyInstallCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "install [path]",
                Short: "Install dependencies for all package managers",
                Long: `Install dependencies for all detected package managers in the project.

Runs the appropriate install command for each package manager found.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("📦 Installing dependencies in: %s", projectPath)
                        fmt.Printf("📦 Installing dependencies in: %s\n\n", projectPath)

                        results, err := app.DependencyMgr.InstallAllDependencies(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to install dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("❌ No package managers found\n")
                                return nil
                        }</span>

                        <span class="cov0" title="0">successCount := 0
                        for _, result := range results </span><span class="cov0" title="0">{
                                if result.Success </span><span class="cov0" title="0">{
                                        fmt.Printf("✅ %s: installed successfully (%s)\n", result.PackageManager, result.Duration)
                                        successCount++
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("❌ %s: failed - %s\n", result.PackageManager, result.Error)
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("\n📊 Summary: %d/%d package managers installed successfully\n", successCount, len(results))

                        return nil</span>
                },
        }
}

// newDependencyUpdateCmd updates dependencies for detected package managers
func newDependencyUpdateCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "update [path]",
                Short: "Update dependencies for detected package managers",
                Long: `Update dependencies for all detected package managers in the current or specified project directory.
                
This will run the appropriate update command for each detected package manager (npm update, cargo update, etc.).`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">abs, err := filepath.Abs(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve project path: %w", err)
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("⬆️ Updating dependencies in: %s", abs)
                        fmt.Printf("⬆️ Updating dependencies in: %s\n\n", abs)

                        // Update dependencies for all detected package managers
                        results, err := app.DependencyMgr.UpdateAllDependencies(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("❌ No package managers found to update\n")
                                return nil
                        }</span>

                        // Display results
                        <span class="cov0" title="0">successCount := 0
                        for _, result := range results </span><span class="cov0" title="0">{
                                if result.Success </span><span class="cov0" title="0">{
                                        successCount++
                                        fmt.Printf("✅ %s: updated successfully (took %s)\n", result.PackageManager, result.Duration)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("❌ %s: failed - %s\n", result.PackageManager, result.Error)
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("\n📊 Summary: %d/%d package managers updated successfully\n", successCount, len(results))

                        return nil</span>
                },
        }
}

// newDependencyAuditCmd audits dependencies for vulnerabilities
func newDependencyAuditCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "audit [path]",
                Short: "Audit dependencies for security vulnerabilities",
                Long: `Audit dependencies for security vulnerabilities using appropriate tools for each package manager.
                
This will run security audits using tools like npm audit, cargo-audit, pip-audit, etc.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">abs, err := filepath.Abs(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve project path: %w", err)
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("🔍 Auditing dependencies in: %s", abs)
                        fmt.Printf("🔍 Auditing dependencies for vulnerabilities in: %s\n\n", abs)

                        // Audit dependencies for all detected package managers
                        auditResults, err := app.DependencyMgr.AuditAllDependencies(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to audit dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(auditResults) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("✅ No vulnerabilities found or no compatible audit tools available\n")
                                return nil
                        }</span>

                        // Display vulnerability results
                        <span class="cov0" title="0">fmt.Printf("🚨 Found %d vulnerabilities:\n\n", len(auditResults))

                        criticalCount := 0
                        highCount := 0
                        moderateCount := 0
                        lowCount := 0

                        for _, vuln := range auditResults </span><span class="cov0" title="0">{
                                severityIcon := "⚠️"
                                switch strings.ToLower(vuln.Severity) </span>{
                                case "critical":<span class="cov0" title="0">
                                        severityIcon = "🔴"
                                        criticalCount++</span>
                                case "high":<span class="cov0" title="0">
                                        severityIcon = "🟠"
                                        highCount++</span>
                                case "moderate":<span class="cov0" title="0">
                                        severityIcon = "🟡"
                                        moderateCount++</span>
                                case "low":<span class="cov0" title="0">
                                        severityIcon = "🟢"
                                        lowCount++</span>
                                }

                                <span class="cov0" title="0">fmt.Printf("%s %s - %s\n", severityIcon, vuln.ID, vuln.Title)
                                fmt.Printf("   Description: %s\n", vuln.Description)
                                if vuln.FixedIn != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("   Fixed in: %s\n", vuln.FixedIn)
                                }</span>
                                <span class="cov0" title="0">if vuln.Reference != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("   Reference: %s\n", vuln.Reference)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("📊 Vulnerability Summary:\n")
                        fmt.Printf("   🔴 Critical: %d\n", criticalCount)
                        fmt.Printf("   🟠 High: %d\n", highCount)
                        fmt.Printf("   🟡 Moderate: %d\n", moderateCount)
                        fmt.Printf("   🟢 Low: %d\n", lowCount)

                        return nil</span>
                },
        }
}

// newDependencyOutdatedCmd shows outdated dependencies
func newDependencyOutdatedCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "outdated [path]",
                Short: "Show outdated dependencies",
                Long: `Show outdated dependencies for all detected package managers in the current or specified project directory.
                
This will check for available updates using tools like npm outdated, cargo-outdated, pip list --outdated, etc.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">abs, err := filepath.Abs(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve project path: %w", err)
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("📊 Checking outdated dependencies in: %s", abs)
                        fmt.Printf("📊 Checking outdated dependencies in: %s\n\n", abs)

                        // Get outdated dependencies for all detected package managers
                        outdatedDeps, err := app.DependencyMgr.GetAllOutdatedDependencies(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to check outdated dependencies: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(outdatedDeps) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("✅ All dependencies are up to date!\n")
                                return nil
                        }</span>

                        // Group by package manager
                        <span class="cov0" title="0">pmGroups := make(map[string][]*pkg.DependencyInfo)
                        for _, dep := range outdatedDeps </span><span class="cov0" title="0">{
                                pmGroups[dep.PackageManager] = append(pmGroups[dep.PackageManager], dep)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("📋 Found %d outdated dependencies:\n\n", len(outdatedDeps))

                        for pmType, deps := range pmGroups </span><span class="cov0" title="0">{
                                fmt.Printf("📦 %s:\n", strings.ToUpper(pmType))
                                for _, dep := range deps </span><span class="cov0" title="0">{
                                        fmt.Printf("   %s: %s → %s", dep.Name, dep.CurrentVersion, dep.LatestVersion)
                                        if dep.RequestedVersion != "" &amp;&amp; dep.RequestedVersion != dep.CurrentVersion </span><span class="cov0" title="0">{
                                                fmt.Printf(" (requested: %s)", dep.RequestedVersion)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }
}

// newDependencyReportCmd generates comprehensive dependency reports
func newDependencyReportCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var outputFormat string

        cmd := &amp;cobra.Command{
                Use:   "report [path]",
                Short: "Generate comprehensive dependency report",
                Long: `Generate a comprehensive dependency report including dependency trees, vulnerability analysis,
outdated packages, and package manager health for the current or specified project directory.

Output formats:
  - text: Human-readable text format (default)
  - json: Machine-readable JSON format`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">abs, err := filepath.Abs(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve project path: %w", err)
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("📊 Generating dependency report for: %s", abs)

                        // Generate comprehensive report
                        report, err := app.DependencyMgr.GenerateDependencyReport(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to generate dependency report: %w", err)
                        }</span>

                        // Output in requested format
                        <span class="cov0" title="0">if outputFormat == "json" </span><span class="cov0" title="0">{
                                encoder := json.NewEncoder(os.Stdout)
                                encoder.SetIndent("", "  ")
                                return encoder.Encode(report)
                        }</span>

                        // Text format output
                        <span class="cov0" title="0">fmt.Printf("📊 Dependency Report for: %s\n", abs)
                        fmt.Printf("Generated: %s\n\n", report.GeneratedAt)

                        // Summary
                        fmt.Printf("📋 Summary:\n")
                        fmt.Printf("   Total Dependencies: %d\n", report.TotalDependencies)
                        fmt.Printf("   Direct Dependencies: %d\n", report.DirectDependencies)
                        fmt.Printf("   Indirect Dependencies: %d\n", report.IndirectDependencies)
                        fmt.Printf("   Outdated Dependencies: %d\n", report.OutdatedDependencies)
                        fmt.Printf("   Vulnerabilities: %d\n", report.Vulnerabilities)
                        fmt.Printf("   Security Score: %.1f/100\n\n", report.SecurityScore)

                        // Package Managers
                        fmt.Printf("📦 Detected Package Managers:\n")
                        for _, pm := range report.PackageManagers </span><span class="cov0" title="0">{
                                statusIcon := "✅"
                                if !pm.Available </span><span class="cov0" title="0">{
                                        statusIcon = "❌"
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("   %s %s (%s)\n", statusIcon, pm.Name, pm.Version)
                                for _, configFile := range pm.ConfigFiles </span><span class="cov0" title="0">{
                                        fmt.Printf("     📄 %s\n", configFile)
                                }</span>
                        }

                        <span class="cov0" title="0">if report.Vulnerabilities &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\n🚨 Security Vulnerabilities: %d found\n", report.Vulnerabilities)
                                fmt.Printf("   See 'dependency audit' for detailed vulnerability information\n")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;outputFormat, "format", "f", "text", "Output format (text|json)")

        return cmd</span>
}

// newDependencyCleanCmd cleans package manager caches
func newDependencyCleanCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "clean [path]",
                Short: "Clean package manager caches",
                Long: `Clean caches for all detected package managers in the current or specified project directory.
                
This will run cache cleaning commands like npm cache clean, cargo clean, pip cache purge, etc.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>

                        <span class="cov0" title="0">abs, err := filepath.Abs(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve project path: %w", err)
                        }</span>

                        <span class="cov0" title="0">app.Logger.Infof("🧹 Cleaning package manager caches in: %s", abs)
                        fmt.Printf("🧹 Cleaning package manager caches in: %s\n\n", abs)

                        // Clean caches for all detected package managers
                        results, err := app.DependencyMgr.CleanAllCaches(projectPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to clean caches: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("❌ No package managers found to clean\n")
                                return nil
                        }</span>

                        // Display results
                        <span class="cov0" title="0">successCount := 0
                        for _, result := range results </span><span class="cov0" title="0">{
                                if result.Success </span><span class="cov0" title="0">{
                                        successCount++
                                        fmt.Printf("✅ %s: cache cleaned successfully (took %s)\n", result.PackageManager, result.Duration)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("❌ %s: failed - %s\n", result.PackageManager, result.Error)
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("\n📊 Summary: %d/%d package managers cleaned successfully\n", successCount, len(results))

                        return nil</span>
                },
        }
}

// newHotReloadCmd creates the hot reload command with subcommands
func newHotReloadCmd(app *pkg.AppContainer) *cobra.Command <span class="cov8" title="1">{
        var hotReloadCmd = &amp;cobra.Command{
                Use:   "hotreload",
                Short: "Hot reload functionality for faster development cycles",
                Long: `Hot reload provides automatic file watching, building, and container synchronization
for faster development cycles. Changes to your project files are automatically detected,
built (if needed), and synchronized with the running container.

This feature supports multiple project types including Go, Node.js, Python, Rust, and Java.`,
        }

        // Command flags
        var (
                hotReloadContainerFlag string
                hotReloadWatchPatternsFlag []string
                hotReloadIgnorePatternsFlag []string
                hotReloadDebounceFlag int
                hotReloadDisableBuildFlag bool
                hotReloadDisableSyncFlag bool
                hotReloadVerboseFlag bool
        )

        // Start command
        var hotReloadStartCmd = &amp;cobra.Command{
                Use:   "start [project-path]",
                Short: "Start hot reload for a project",
                Long: `Start hot reload monitoring for a project. This will:

1. Auto-detect the project type (Go, Node.js, Python, etc.)
2. Set up file watching with appropriate patterns
3. Configure build triggers for the detected language
4. Start container synchronization for fast file updates

If no project path is specified, the current directory is used.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        ctx := context.Background()

                        // Determine project path
                        projectPath := "."
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                projectPath = args[0]
                        }</span>
                        
                        // Get absolute project path
                        <span class="cov0" title="0">if !strings.HasPrefix(projectPath, "/") </span><span class="cov0" title="0">{
                                if projectPath == "." </span><span class="cov0" title="0">{
                                        cwd, err := os.Getwd()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to get current directory: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">projectPath = cwd</span>
                                } else<span class="cov0" title="0"> {
                                        cwd, err := os.Getwd()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to get current directory: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">projectPath = cwd + "/" + strings.TrimPrefix(projectPath, "./")</span>
                                }
                        }

                        <span class="cov0" title="0">fmt.Printf("🔥 Starting hot reload for project: %s\n", projectPath)

                        // Determine container ID
                        containerID := hotReloadContainerFlag
                        if containerID == "" </span><span class="cov0" title="0">{
                                // Auto-detect running container for this project
                                projectHash := app.DockerMgr.GenerateProjectHash(projectPath)
                                
                                // Get current configuration
                                config, err := app.ConfigMgr.LoadConfig()
                                if err != nil </span><span class="cov0" title="0">{
                                        // Use default account if no config
                                        config = &amp;pkg.Config{Account: "default"}
                                }</span>
                                
                                // Generate expected container name
                                <span class="cov0" title="0">variant := config.Variant
                                if variant == "" </span><span class="cov0" title="0">{
                                        variant = "base"
                                }</span>
                                
                                <span class="cov0" title="0">architecture, _ := app.ArchDetector.GetHostArchitecture()
                                containerName := fmt.Sprintf("claude-reactor-v2-%s-%s-%s-%s", variant, architecture, projectHash, config.Account)
                                
                                // Check if container is running
                                running, err := app.DockerMgr.IsContainerRunning(ctx, containerName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to check container status: %w", err)
                                }</span>
                                
                                <span class="cov0" title="0">if !running </span><span class="cov0" title="0">{
                                        return fmt.Errorf("no running container found for project. Please start a container first or specify --container")
                                }</span>
                                
                                // Get container status to get ID
                                <span class="cov0" title="0">status, err := app.DockerMgr.GetContainerStatus(ctx, containerName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to get container status: %w", err)
                                }</span>
                                
                                <span class="cov0" title="0">containerID = status.ID
                                fmt.Printf("🔍 Auto-detected container: %s\n", containerID[:12])</span>
                        }

                        // Create hot reload options
                        <span class="cov0" title="0">options := &amp;pkg.HotReloadOptions{
                                AutoDetect:          true,
                                EnableNotifications: true,
                        }

                        // Configure watch patterns if specified
                        if len(hotReloadWatchPatternsFlag) &gt; 0 || len(hotReloadIgnorePatternsFlag) &gt; 0 || hotReloadDebounceFlag != 500 </span><span class="cov0" title="0">{
                                options.WatchConfig = &amp;pkg.WatchConfig{
                                        IncludePatterns: hotReloadWatchPatternsFlag,
                                        ExcludePatterns: hotReloadIgnorePatternsFlag,
                                        DebounceDelay:   hotReloadDebounceFlag,
                                        Recursive:       true,
                                        EnableBuild:     !hotReloadDisableBuildFlag,
                                        EnableHotReload: !hotReloadDisableSyncFlag,
                                        ContainerName:   containerID,
                                }
                        }</span>

                        // Start hot reload
                        <span class="cov0" title="0">session, err := app.HotReloadMgr.StartHotReload(projectPath, containerID, options)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start hot reload: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("✅ Hot reload started successfully\n")
                        fmt.Printf("📋 Session ID: %s\n", session.ID)
                        if session.ProjectInfo != nil </span><span class="cov0" title="0">{
                                fmt.Printf("📁 Project Type: %s (%s) - %.1f%% confidence\n", 
                                        session.ProjectInfo.Type, session.ProjectInfo.Framework, session.ProjectInfo.Confidence)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("🔍 Watching: %s\n", projectPath)
                        fmt.Printf("📦 Container: %s\n", containerID[:12])

                        if hotReloadVerboseFlag </span><span class="cov0" title="0">{
                                fmt.Print("\n📊 Session Details:\n")
                                fmt.Printf("   Start Time: %s\n", session.StartTime)
                                fmt.Printf("   Status: %s\n", session.Status)
                                if session.WatchSession != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("   Watch Session: %s\n", session.WatchSession.ID)
                                }</span>
                                <span class="cov0" title="0">if session.SyncSession != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("   Sync Session: %s\n", session.SyncSession.ID)
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Print("\n💡 Use 'claude-reactor hotreload status' to monitor progress\n")
                        fmt.Printf("💡 Use 'claude-reactor hotreload stop %s' to stop\n", session.ID)
                        
                        return nil</span>
                },
        }

        // Stop command
        <span class="cov8" title="1">var hotReloadStopCmd = &amp;cobra.Command{
                Use:   "stop &lt;session-id&gt;",
                Short: "Stop an active hot reload session",
                Long: `Stop an active hot reload session by its ID. This will:

1. Stop file watching
2. Stop build triggers
3. Stop container synchronization
4. Clean up session resources

Use 'hotreload list' to see active sessions and their IDs.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sessionID := args[0]
                        
                        fmt.Printf("🛑 Stopping hot reload session: %s\n", sessionID)

                        // Stop hot reload
                        err := app.HotReloadMgr.StopHotReload(sessionID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to stop hot reload: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("✅ Hot reload session stopped: %s\n", sessionID)
                        return nil</span>
                },
        }

        // Status command
        <span class="cov8" title="1">var hotReloadStatusCmd = &amp;cobra.Command{
                Use:   "status [session-id]",
                Short: "Show hot reload status",
                Long: `Show detailed status information for hot reload sessions.

If a session ID is provided, shows detailed status for that specific session.
If no session ID is provided, shows a summary of all active sessions.`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                // Show detailed status for specific session
                                sessionID := args[0]
                                status, err := app.HotReloadMgr.GetHotReloadStatus(sessionID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to get hot reload status: %w", err)
                                }</span>

                                <span class="cov0" title="0">fmt.Print("🔥 Hot Reload Session Status\n")
                                fmt.Printf("📋 Session ID: %s\n", status.SessionID)
                                fmt.Printf("📊 Status: %s\n", status.Status)
                                fmt.Printf("👀 Watching: %s\n", status.WatchingStatus)
                                fmt.Printf("🔨 Build: %s\n", status.BuildStatus)
                                fmt.Printf("🔄 Sync: %s\n", status.SyncStatus)
                                fmt.Printf("⚡ Hot Reload: %s\n", status.HotReloadStatus)

                                if status.Metrics != nil </span><span class="cov0" title="0">{
                                        fmt.Print("\n📈 Metrics:\n")
                                        fmt.Printf("   Uptime: %s\n", status.Metrics.Uptime)
                                        fmt.Printf("   Total Changes: %d\n", status.Metrics.TotalChanges)
                                        fmt.Printf("   Build Success Rate: %.1f%%\n", status.Metrics.BuildSuccessRate)
                                        fmt.Printf("   Average Build Time: %s\n", status.Metrics.AverageBuildTime)
                                        fmt.Printf("   Average Sync Time: %s\n", status.Metrics.AverageSyncTime)
                                }</span>

                                <span class="cov0" title="0">if len(status.RecentActivity) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Print("\n📋 Recent Activity:\n")
                                        for _, activity := range status.RecentActivity </span><span class="cov0" title="0">{
                                                timestamp, _ := time.Parse(time.RFC3339, activity.Timestamp)
                                                fmt.Printf("   %s [%s] %s\n", 
                                                        timestamp.Format("15:04:05"), 
                                                        strings.ToUpper(activity.Level), 
                                                        activity.Message)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // Show summary of all sessions
                                sessions, err := app.HotReloadMgr.GetHotReloadSessions()
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to get hot reload sessions: %w", err)
                                }</span>

                                <span class="cov0" title="0">if len(sessions) == 0 </span><span class="cov0" title="0">{
                                        fmt.Print("📭 No active hot reload sessions\n")
                                        fmt.Print("💡 Use 'claude-reactor hotreload start' to begin hot reloading\n")
                                        return nil
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("🔥 Active Hot Reload Sessions (%d)\n\n", len(sessions))

                                for i, session := range sessions </span><span class="cov0" title="0">{
                                        fmt.Printf("%d. Session: %s\n", i+1, session.ID)
                                        fmt.Printf("   📁 Project: %s\n", session.ProjectPath)
                                        if session.ProjectInfo != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("   🏷️  Type: %s (%s)\n", session.ProjectInfo.Type, session.ProjectInfo.Framework)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Printf("   📦 Container: %s\n", session.ContainerID[:12])
                                        fmt.Printf("   📊 Status: %s\n", session.Status)
                                        
                                        startTime, _ := time.Parse(time.RFC3339, session.StartTime)
                                        uptime := time.Since(startTime)
                                        fmt.Printf("   ⏱️  Uptime: %s\n", formatDuration(uptime))
                                        
                                        if session.LastActivity != "" </span><span class="cov0" title="0">{
                                                lastActivity, _ := time.Parse(time.RFC3339, session.LastActivity)
                                                fmt.Printf("   🕐 Last Activity: %s ago\n", time.Since(lastActivity).Truncate(time.Second))
                                        }</span>
                                        
                                        <span class="cov0" title="0">if i &lt; len(sessions)-1 </span><span class="cov0" title="0">{
                                                fmt.Print("\n")
                                        }</span>
                                }

                                <span class="cov0" title="0">fmt.Print("\n💡 Use 'hotreload status &lt;session-id&gt;' for detailed information\n")</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                },
        }

        // List command (alias for status with no args)
        <span class="cov8" title="1">var hotReloadListCmd = &amp;cobra.Command{
                Use:   "list",
                Short: "List all hot reload sessions",
                Long: `List all active hot reload sessions with their IDs, project paths,
container information, and current status.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return hotReloadStatusCmd.RunE(cmd, []string{}) // Reuse the status command logic
                }</span>,
        }

        // Config command
        <span class="cov8" title="1">var hotReloadConfigCmd = &amp;cobra.Command{
                Use:   "config &lt;session-id&gt;",
                Short: "Update hot reload configuration",
                Long: `Update the configuration for an active hot reload session.

This allows you to modify watching patterns, build settings, and sync options
without stopping and restarting the session.`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        sessionID := args[0]
                        
                        // Check if any config flags were provided
                        hasConfigChanges := len(hotReloadWatchPatternsFlag) &gt; 0 || 
                                len(hotReloadIgnorePatternsFlag) &gt; 0 || 
                                hotReloadDebounceFlag != -1 ||
                                hotReloadDisableBuildFlag ||
                                hotReloadDisableSyncFlag

                        if !hasConfigChanges </span><span class="cov0" title="0">{
                                return fmt.Errorf("no configuration changes specified. Use --watch, --ignore, --debounce, --no-build, or --no-sync flags")
                        }</span>

                        // Create new options with the specified changes
                        <span class="cov0" title="0">options := &amp;pkg.HotReloadOptions{
                                AutoDetect:          true,
                                EnableNotifications: true,
                        }

                        // Configure watch patterns
                        if len(hotReloadWatchPatternsFlag) &gt; 0 || len(hotReloadIgnorePatternsFlag) &gt; 0 || hotReloadDebounceFlag != -1 </span><span class="cov0" title="0">{
                                options.WatchConfig = &amp;pkg.WatchConfig{
                                        Recursive:       true,
                                        EnableBuild:     !hotReloadDisableBuildFlag,
                                        EnableHotReload: !hotReloadDisableSyncFlag,
                                }
                                
                                if len(hotReloadWatchPatternsFlag) &gt; 0 </span><span class="cov0" title="0">{
                                        options.WatchConfig.IncludePatterns = hotReloadWatchPatternsFlag
                                }</span>
                                
                                <span class="cov0" title="0">if len(hotReloadIgnorePatternsFlag) &gt; 0 </span><span class="cov0" title="0">{
                                        options.WatchConfig.ExcludePatterns = hotReloadIgnorePatternsFlag
                                }</span>
                                
                                <span class="cov0" title="0">if hotReloadDebounceFlag != -1 </span><span class="cov0" title="0">{
                                        options.WatchConfig.DebounceDelay = hotReloadDebounceFlag
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("🔧 Updating hot reload configuration for session: %s\n", sessionID)

                        // Update configuration
                        err := app.HotReloadMgr.UpdateHotReloadConfig(sessionID, options)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update hot reload configuration: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("✅ Hot reload configuration updated for session: %s\n", sessionID)

                        // Show what was updated
                        if len(hotReloadWatchPatternsFlag) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("👀 Updated watch patterns: %v\n", hotReloadWatchPatternsFlag)
                        }</span>
                        <span class="cov0" title="0">if len(hotReloadIgnorePatternsFlag) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("🚫 Updated ignore patterns: %v\n", hotReloadIgnorePatternsFlag)
                        }</span>
                        <span class="cov0" title="0">if hotReloadDebounceFlag != -1 </span><span class="cov0" title="0">{
                                fmt.Printf("⏱️  Updated debounce delay: %dms\n", hotReloadDebounceFlag)
                        }</span>
                        <span class="cov0" title="0">if hotReloadDisableBuildFlag </span><span class="cov0" title="0">{
                                fmt.Print("🔨 Disabled automatic building\n")
                        }</span>
                        <span class="cov0" title="0">if hotReloadDisableSyncFlag </span><span class="cov0" title="0">{
                                fmt.Print("🔄 Disabled file synchronization\n")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        }

        // Add flags to start command
        <span class="cov8" title="1">hotReloadStartCmd.Flags().StringVarP(&amp;hotReloadContainerFlag, "container", "c", "", "Target container name or ID (auto-detected if not specified)")
        hotReloadStartCmd.Flags().StringSliceVar(&amp;hotReloadWatchPatternsFlag, "watch", nil, "File patterns to watch (e.g., '**/*.go', '*.js')")
        hotReloadStartCmd.Flags().StringSliceVar(&amp;hotReloadIgnorePatternsFlag, "ignore", nil, "File patterns to ignore (e.g., 'node_modules/', '*.tmp')")
        hotReloadStartCmd.Flags().IntVar(&amp;hotReloadDebounceFlag, "debounce", 500, "Debounce delay in milliseconds")
        hotReloadStartCmd.Flags().BoolVar(&amp;hotReloadDisableBuildFlag, "no-build", false, "Disable automatic building")
        hotReloadStartCmd.Flags().BoolVar(&amp;hotReloadDisableSyncFlag, "no-sync", false, "Disable file synchronization")
        hotReloadStartCmd.Flags().BoolVarP(&amp;hotReloadVerboseFlag, "verbose", "v", false, "Verbose output")

        // Add flags to config command
        hotReloadConfigCmd.Flags().StringSliceVar(&amp;hotReloadWatchPatternsFlag, "watch", nil, "Update file patterns to watch")
        hotReloadConfigCmd.Flags().StringSliceVar(&amp;hotReloadIgnorePatternsFlag, "ignore", nil, "Update file patterns to ignore")
        hotReloadConfigCmd.Flags().IntVar(&amp;hotReloadDebounceFlag, "debounce", -1, "Update debounce delay in milliseconds")
        hotReloadConfigCmd.Flags().BoolVar(&amp;hotReloadDisableBuildFlag, "no-build", false, "Disable automatic building")
        hotReloadConfigCmd.Flags().BoolVar(&amp;hotReloadDisableSyncFlag, "no-sync", false, "Disable file synchronization")

        // Add subcommands
        hotReloadCmd.AddCommand(
                hotReloadStartCmd,
                hotReloadStopCmd,
                hotReloadStatusCmd,
                hotReloadListCmd,
                hotReloadConfigCmd,
        )

        return hotReloadCmd</span>
}

// Helper function for formatting duration
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%ds", int(d.Seconds()))
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm %ds", int(d.Minutes()), int(d.Seconds())%60)
        }</span> else<span class="cov0" title="0"> if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh %dm", int(d.Hours()), int(d.Minutes())%60)
        }</span> else<span class="cov0" title="0"> {
                days := int(d.Hours()) / 24
                hours := int(d.Hours()) % 24
                return fmt.Sprintf("%dd %dh", days, hours)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package architecture

import (
        "fmt"
        "runtime"
        "strings"

        "claude-reactor/pkg"
)

// detector implements the ArchitectureDetector interface
type detector struct {
        logger pkg.Logger
}

// NewDetector creates a new architecture detector
func NewDetector(logger pkg.Logger) pkg.ArchitectureDetector <span class="cov8" title="1">{
        return &amp;detector{
                logger: logger,
        }
}</span>

// GetHostArchitecture returns the host system architecture
// Replicates the detect_architecture() bash function
func (d *detector) GetHostArchitecture() (string, error) <span class="cov8" title="1">{
        arch := runtime.GOARCH
        
        d.logger.Debugf("Detected raw architecture: %s", arch)
        
        switch arch </span>{
        case "amd64":<span class="cov0" title="0">
                return "amd64", nil</span>
        case "arm64":<span class="cov8" title="1">
                return "arm64", nil</span>
        case "386":<span class="cov0" title="0">
                return "i386", nil</span>
        case "arm":<span class="cov0" title="0">
                return "arm", nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported architecture: %s", arch)</span>
        }
}

// GetDockerPlatform returns the Docker platform format
// Replicates the get_docker_platform() bash function
func (d *detector) GetDockerPlatform() (string, error) <span class="cov8" title="1">{
        arch, err := d.GetHostArchitecture()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to detect host architecture: %w", err)
        }</span>
        
        <span class="cov8" title="1">var platform string
        switch arch </span>{
        case "amd64":<span class="cov0" title="0">
                platform = "linux/amd64"</span>
        case "arm64":<span class="cov8" title="1">
                platform = "linux/arm64"</span>
        case "i386":<span class="cov0" title="0">
                platform = "linux/386"</span>
        case "arm":<span class="cov0" title="0">
                platform = "linux/arm/v7"</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported architecture for Docker platform: %s", arch)</span>
        }
        
        <span class="cov8" title="1">d.logger.Debugf("Docker platform: %s", platform)
        return platform, nil</span>
}

// IsMultiArchSupported checks if the system supports multi-architecture containers
func (d *detector) IsMultiArchSupported() bool <span class="cov8" title="1">{
        // Most modern Docker installations support multi-arch
        // This could be enhanced to actually check Docker buildx availability
        return true
}</span>

// GetContainerName generates a container name with architecture suffix
// Following the pattern from bash: claude-reactor-{variant}-{arch}-{account}
func GetContainerName(variant, account string, archDetector pkg.ArchitectureDetector) (string, error) <span class="cov8" title="1">{
        arch, err := archDetector.GetHostArchitecture()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get architecture for container name: %w", err)
        }</span>
        
        // Base container name parts
        <span class="cov8" title="1">parts := []string{"claude-reactor", variant, arch}
        
        // Add account if specified, otherwise use "default"
        if account != "" </span><span class="cov8" title="1">{
                parts = append(parts, account)
        }</span> else<span class="cov8" title="1"> {
                parts = append(parts, "default")
        }</span>
        
        <span class="cov8" title="1">return strings.Join(parts, "-"), nil</span>
}

// GetImageName generates an image name with architecture suffix
func GetImageName(variant string, archDetector pkg.ArchitectureDetector) (string, error) <span class="cov8" title="1">{
        arch, err := archDetector.GetHostArchitecture()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get architecture for image name: %w", err)
        }</span>
        
        <span class="cov8" title="1">return fmt.Sprintf("claude-reactor-%s:%s", variant, arch), nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        
        "claude-reactor/pkg"
)

// manager implements the ConfigManager interface
type manager struct {
        logger pkg.Logger
}

// NewManager creates a new configuration manager
func NewManager(logger pkg.Logger) pkg.ConfigManager <span class="cov8" title="1">{
        return &amp;manager{
                logger: logger,
        }
}</span>

// LoadConfig loads configuration from file or creates default
func (m *manager) LoadConfig() (*pkg.Config, error) <span class="cov8" title="1">{
        // TODO: Implement YAML configuration loading
        m.logger.Debug("Loading configuration (stub implementation)")
        return m.GetDefaultConfig(), nil
}</span>

// SaveConfig persists configuration to file
func (m *manager) SaveConfig(config *pkg.Config) error <span class="cov8" title="1">{
        // Simple stub implementation for backward compatibility
        // Write basic .claude-reactor file in bash script format
        file, err := os.Create(".claude-reactor")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        // Write configuration in bash script format for compatibility
        fmt.Fprintf(file, "variant=%s\n", config.Variant)
        if config.Account != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(file, "account=%s\n", config.Account)
        }</span>
        <span class="cov8" title="1">if config.DangerMode </span><span class="cov8" title="1">{
                fmt.Fprintf(file, "danger=true\n")
        }</span>
        
        <span class="cov8" title="1">m.logger.Infof("Configuration saved: variant=%s, account=%s", config.Variant, config.Account)
        return nil</span>
}

// ValidateConfig validates configuration structure and values
func (m *manager) ValidateConfig(config *pkg.Config) error <span class="cov8" title="1">{
        // TODO: Implement configuration validation
        if config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration cannot be nil")
        }</span>
        
        <span class="cov8" title="1">validVariants := []string{"base", "go", "full", "cloud", "k8s"}
        for _, variant := range validVariants </span><span class="cov8" title="1">{
                if config.Variant == variant </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        
        <span class="cov8" title="1">return fmt.Errorf("invalid variant: %s", config.Variant)</span>
}

// GetDefaultConfig returns a default configuration with auto-detection
func (m *manager) GetDefaultConfig() *pkg.Config <span class="cov8" title="1">{
        variant, _ := m.AutoDetectVariant("")
        return &amp;pkg.Config{
                Variant:     variant,
                Account:     "",
                DangerMode:  false,
                ProjectPath: "",
                Metadata:    make(map[string]string),
        }
}</span>

// AutoDetectVariant performs basic project type auto-detection
func (m *manager) AutoDetectVariant(projectPath string) (string, error) <span class="cov8" title="1">{
        if projectPath == "" </span><span class="cov8" title="1">{
                var err error
                projectPath, err = os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "base", err
                }</span>
        }
        
        // Check project directory for project indicators
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "go.mod")); err == nil </span><span class="cov8" title="1">{
                m.logger.Debug("Detected Go project (go.mod found)")
                return "go", nil
        }</span>
        
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "Cargo.toml")); err == nil </span><span class="cov8" title="1">{
                m.logger.Debug("Detected Rust project (Cargo.toml found)")
                return "full", nil // Rust is in the full variant
        }</span>
        
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "package.json")); err == nil </span><span class="cov8" title="1">{
                m.logger.Debug("Detected Node.js project (package.json found)")
                return "base", nil // Node.js is in base
        }</span>
        
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "requirements.txt")); err == nil </span><span class="cov8" title="1">{
                m.logger.Debug("Detected Python project (requirements.txt found)")
                return "base", nil // Python is in base
        }</span>
        
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "pom.xml")); err == nil </span><span class="cov8" title="1">{
                m.logger.Debug("Detected Java project (pom.xml found)")
                return "full", nil // Java is in full
        }</span>
        
        // Check for Kubernetes files
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "helm")); err == nil </span><span class="cov8" title="1">{
                return "k8s", nil
        }</span>
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "k8s")); err == nil </span><span class="cov8" title="1">{
                return "k8s", nil
        }</span>
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "kubernetes")); err == nil </span><span class="cov8" title="1">{
                return "k8s", nil
        }</span>
        
        // Check for cloud configuration files
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, ".aws")); err == nil </span><span class="cov8" title="1">{
                return "cloud", nil
        }</span>
        <span class="cov8" title="1">if _, err := os.Stat(filepath.Join(projectPath, "terraform")); err == nil </span><span class="cov8" title="1">{
                return "cloud", nil
        }</span>
        
        <span class="cov8" title="1">m.logger.Debug("No project type detected, using base variant")
        return "base", nil</span>
}

// ListAccounts returns available Claude accounts
func (m *manager) ListAccounts() ([]string, error) <span class="cov0" title="0">{
        // TODO: Implement account listing from ~/.claude-reactor directory
        m.logger.Debug("Listing Claude accounts (stub implementation)")
        return []string{"default"}, nil
}</pre>
		
		<pre class="file" id="file3" style="display: none">package internal

import (
        "claude-reactor/pkg"
        "claude-reactor/internal/architecture"
        "claude-reactor/internal/auth"
        "claude-reactor/internal/config"
        "claude-reactor/internal/dependency"
        "claude-reactor/internal/devcontainer"
        "claude-reactor/internal/docker"
        "claude-reactor/internal/hotreload"
        "claude-reactor/internal/logging"
        "claude-reactor/internal/mount"
        "claude-reactor/internal/template"
)

// NewAppContainer creates and initializes the application dependency container
func NewAppContainer() (*pkg.AppContainer, error) <span class="cov8" title="1">{
        // Initialize logger first
        logger := logging.NewLogger()
        
        // Initialize architecture detector
        archDetector := architecture.NewDetector(logger)
        
        // Initialize configuration manager
        configMgr := config.NewManager(logger)
        
        // Initialize Docker manager
        dockerMgr, err := docker.NewManager(logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Initialize authentication manager
        <span class="cov8" title="1">authMgr := auth.NewManager(logger)
        
        // Initialize mount manager
        mountMgr := mount.NewManager(logger)
        
        // Initialize devcontainer manager
        devContainerMgr := devcontainer.NewManager(logger, configMgr)
        
        // Initialize template manager
        templateMgr := template.NewManager(logger, configMgr, devContainerMgr)
        
        // Initialize dependency manager
        dependencyMgr := dependency.NewManager(logger)
        
        // Initialize hot reload components
        fileWatcher := hotreload.NewFileWatcher(logger)
        buildTrigger := hotreload.NewBuildTrigger(logger)
        containerSync := hotreload.NewContainerSync(logger, dockerMgr.GetClient())
        hotReloadMgr := hotreload.NewHotReloadManager(logger, dockerMgr.GetClient())
        
        return &amp;pkg.AppContainer{
                ArchDetector:    archDetector,
                ConfigMgr:       configMgr,
                DockerMgr:       dockerMgr,
                AuthMgr:         authMgr,
                MountMgr:        mountMgr,
                DevContainerMgr: devContainerMgr,
                TemplateMgr:     templateMgr,
                DependencyMgr:   dependencyMgr,
                FileWatcher:     fileWatcher,
                BuildTrigger:    buildTrigger,
                ContainerSync:   containerSync,
                HotReloadMgr:    hotReloadMgr,
                Logger:          logger,
        }, nil</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package logging

import (
        "os"
        "strings"

        "github.com/sirupsen/logrus"
        
        "claude-reactor/pkg"
)

// logger wraps logrus to implement our Logger interface
type logger struct {
        *logrus.Logger
}

// NewLogger creates a new structured logger with appropriate configuration
func NewLogger() pkg.Logger <span class="cov8" title="1">{
        l := logrus.New()
        
        // Set output format
        l.SetFormatter(&amp;logrus.TextFormatter{
                FullTimestamp:   true,
                TimestampFormat: "15:04:05",
                ForceColors:     true,
                DisableQuote:    true,
        })
        
        // Set log level based on environment
        level := getLogLevel()
        l.SetLevel(level)
        
        // Set output to stdout (not stderr) for better CLI experience
        l.SetOutput(os.Stdout)
        
        return &amp;logger{Logger: l}
}</span>

// getLogLevel determines the appropriate log level from environment variables
func getLogLevel() logrus.Level <span class="cov8" title="1">{
        // Check for CLAUDE_REACTOR_LOG_LEVEL environment variable
        envLevel := strings.ToUpper(os.Getenv("CLAUDE_REACTOR_LOG_LEVEL"))
        
        switch envLevel </span>{
        case "DEBUG":<span class="cov8" title="1">
                return logrus.DebugLevel</span>
        case "INFO":<span class="cov8" title="1">
                return logrus.InfoLevel</span>
        case "WARN", "WARNING":<span class="cov8" title="1">
                return logrus.WarnLevel</span>
        case "ERROR":<span class="cov8" title="1">
                return logrus.ErrorLevel</span>
        case "FATAL":<span class="cov8" title="1">
                return logrus.FatalLevel</span>
        default:<span class="cov8" title="1">
                // Default to INFO level for production use
                return logrus.InfoLevel</span>
        }
}

// WithField creates a new logger with a single field
func (l *logger) WithField(key string, value interface{}) pkg.Logger <span class="cov8" title="1">{
        return &amp;logger{Logger: l.Logger.WithField(key, value).Logger}
}</span>

// WithFields creates a new logger with multiple fields
func (l *logger) WithFields(fields map[string]interface{}) pkg.Logger <span class="cov8" title="1">{
        logrusFields := make(logrus.Fields)
        for k, v := range fields </span><span class="cov8" title="1">{
                logrusFields[k] = v
        }</span>
        <span class="cov8" title="1">return &amp;logger{Logger: l.Logger.WithFields(logrusFields).Logger}</span>
}

// Implement the pkg.Logger interface methods that aren't directly available from logrus

// Debug logs a debug message
func (l *logger) Debug(args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Debug(args...)
}</span>

// Info logs an info message
func (l *logger) Info(args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Info(args...)
}</span>

// Warn logs a warning message
func (l *logger) Warn(args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Warn(args...)
}</span>

// Error logs an error message
func (l *logger) Error(args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Error(args...)
}</span>

// Fatal logs a fatal message and exits
func (l *logger) Fatal(args ...interface{}) <span class="cov0" title="0">{
        l.Logger.Fatal(args...)
}</span>

// Debugf logs a formatted debug message
func (l *logger) Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Debugf(format, args...)
}</span>

// Infof logs a formatted info message
func (l *logger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Infof(format, args...)
}</span>

// Warnf logs a formatted warning message
func (l *logger) Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Warnf(format, args...)
}</span>

// Errorf logs a formatted error message
func (l *logger) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.Logger.Errorf(format, args...)
}</span>

// Fatalf logs a formatted fatal message and exits
func (l *logger) Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.Logger.Fatalf(format, args...)
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
